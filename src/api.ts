/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AttachmentModel
 */
export interface AttachmentModel {
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'fileId': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentModel
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentModel
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AttachmentPutModel
 */
export interface AttachmentPutModel {
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModel
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AttachmentPutModelAutoTestStepResultsModel
 */
export interface AttachmentPutModelAutoTestStepResultsModel {
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'outcome'?: string | null;
    /**
     * nested enumeration is allowed
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     * @deprecated
     */
    'stepResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
    /**
     * 
     * @type {Array<AttachmentPutModel>}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'attachments'?: Array<AttachmentPutModel> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AttachmentPutModelAutoTestStepResultsModel
     */
    'parameters'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface AutoTestAverageDurationModel
 */
export interface AutoTestAverageDurationModel {
    /**
     * 
     * @type {number}
     * @memberof AutoTestAverageDurationModel
     */
    'passedAverageDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoTestAverageDurationModel
     */
    'failedAverageDuration'?: number;
}
/**
 * 
 * @export
 * @interface AutoTestIdModel
 */
export interface AutoTestIdModel {
    /**
     * 
     * @type {string}
     * @memberof AutoTestIdModel
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AutoTestModel
 */
export interface AutoTestModel {
    /**
     * 
     * @type {number}
     * @memberof AutoTestModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestModel
     */
    'mustBeApproved'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'lastTestRunId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'lastTestRunName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'lastTestResultId'?: string | null;
    /**
     * Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped
     * @type {string}
     * @memberof AutoTestModel
     */
    'lastTestResultOutcome'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AutoTestModel
     */
    'stabilityPercentage'?: number | null;
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestModel
     */
    'externalId': string;
    /**
     * 
     * @type {Array<LinkPutModel>}
     * @memberof AutoTestModel
     */
    'links'?: Array<LinkPutModel> | null;
    /**
     * This property is used to link autotest with project
     * @type {string}
     * @memberof AutoTestModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'namespace'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'classname'?: string | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModel
     */
    'steps'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModel
     */
    'setup'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModel
     */
    'teardown'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<LabelShortModel>}
     * @memberof AutoTestModel
     */
    'labels'?: Array<LabelShortModel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestModel
     */
    'isFlaky'?: boolean;
}
/**
 * 
 * @export
 * @interface AutoTestModelV2GetModel
 */
export interface AutoTestModelV2GetModel {
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {Array<LinkModel>}
     * @memberof AutoTestModelV2GetModel
     */
    'links'?: Array<LinkModel> | null;
    /**
     * This property is used to link autotest with project
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'namespace'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'classname'?: string | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModelV2GetModel
     */
    'steps'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModelV2GetModel
     */
    'setup'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestModelV2GetModel
     */
    'teardown'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {number}
     * @memberof AutoTestModelV2GetModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {Array<LabelShortModel>}
     * @memberof AutoTestModelV2GetModel
     */
    'labels'?: Array<LabelShortModel> | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestModelV2GetModel
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestModelV2GetModel
     */
    'isDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface AutoTestNamespaceModel
 */
export interface AutoTestNamespaceModel {
    /**
     * 
     * @type {string}
     * @memberof AutoTestNamespaceModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof AutoTestNamespaceModel
     */
    'classes'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface AutoTestPostModel
 */
export interface AutoTestPostModel {
    /**
     * 
     * @type {Set<string>}
     * @memberof AutoTestPostModel
     */
    'workItemIdsForLinkWithAutoTest'?: Set<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestPostModel
     */
    'shouldCreateWorkItem'?: boolean;
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'externalId': string;
    /**
     * 
     * @type {Array<LinkPostModel>}
     * @memberof AutoTestPostModel
     */
    'links'?: Array<LinkPostModel> | null;
    /**
     * This property is used to link autotest with project
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'namespace'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'classname'?: string | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPostModel
     */
    'steps'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPostModel
     */
    'setup'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPostModel
     */
    'teardown'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<LabelPostModel>}
     * @memberof AutoTestPostModel
     */
    'labels'?: Array<LabelPostModel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestPostModel
     */
    'isFlaky'?: boolean;
}
/**
 * 
 * @export
 * @interface AutoTestPutModel
 */
export interface AutoTestPutModel {
    /**
     * Used for search autotest. If value equals Guid mask filled with zeros, search will be executed using ExternalId
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof AutoTestPutModel
     */
    'workItemIdsForLinkWithAutoTest'?: Set<string> | null;
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'externalId': string;
    /**
     * 
     * @type {Array<LinkPutModel>}
     * @memberof AutoTestPutModel
     */
    'links'?: Array<LinkPutModel> | null;
    /**
     * This property is used to link autotest with project
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'namespace'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'classname'?: string | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPutModel
     */
    'steps'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPutModel
     */
    'setup'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestPutModel
     */
    'teardown'?: Array<AutoTestStepModel> | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<LabelPostModel>}
     * @memberof AutoTestPutModel
     */
    'labels'?: Array<LabelPostModel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTestPutModel
     */
    'isFlaky'?: boolean;
}
/**
 * 
 * @export
 * @interface AutoTestResultPostModel
 */
export interface AutoTestResultPostModel {
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'testRunId': string;
    /**
     * 
     * @type {number}
     * @memberof AutoTestResultPostModel
     */
    'testPlanGlobalId': number;
    /**
     * 
     * @type {number}
     * @memberof AutoTestResultPostModel
     */
    'configurationGlobalId': number;
    /**
     * 
     * @type {Array<LinkPostModel>}
     * @memberof AutoTestResultPostModel
     */
    'links'?: Array<LinkPostModel> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoTestResultPostModel
     */
    'failureReasonNames'?: Array<string> | null;
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'autoTestExternalId': string;
    /**
     * Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'outcome': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'traces'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultPostModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AutoTestResultPostModel
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<AttachmentPutModel>}
     * @memberof AutoTestResultPostModel
     */
    'attachments'?: Array<AttachmentPutModel> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AutoTestResultPostModel
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AutoTestResultPostModel
     */
    'properties'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultPostModel
     */
    'stepResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultPostModel
     */
    'setupResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultPostModel
     */
    'teardownResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
}
/**
 * 
 * @export
 * @interface AutoTestResultsForTestRunModel
 */
export interface AutoTestResultsForTestRunModel {
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'configurationId': string;
    /**
     * 
     * @type {Array<LinkPostModel>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'links'?: Array<LinkPostModel> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'failureReasonNames'?: Array<string> | null;
    /**
     * This property is used to set autotest identifier from client system
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'autoTestExternalId': string;
    /**
     * Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'outcome': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'traces'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutoTestResultsForTestRunModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AutoTestResultsForTestRunModel
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<AttachmentPutModel>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'attachments'?: Array<AttachmentPutModel> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AutoTestResultsForTestRunModel
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AutoTestResultsForTestRunModel
     */
    'properties'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'stepResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'setupResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
    /**
     * 
     * @type {Array<AttachmentPutModelAutoTestStepResultsModel>}
     * @memberof AutoTestResultsForTestRunModel
     */
    'teardownResults'?: Array<AttachmentPutModelAutoTestStepResultsModel> | null;
}
/**
 * 
 * @export
 * @interface AutoTestStepModel
 */
export interface AutoTestStepModel {
    /**
     * 
     * @type {string}
     * @memberof AutoTestStepModel
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AutoTestStepModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<AutoTestStepModel>}
     * @memberof AutoTestStepModel
     * @deprecated
     */
    'steps'?: Array<AutoTestStepModel> | null;
}
/**
 * 
 * @export
 * @interface ConfigurationModel
 */
export interface ConfigurationModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationModel
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConfigurationModel
     */
    'capabilities': { [key: string]: string; };
    /**
     * This property is used to link configuration with project
     * @type {string}
     * @memberof ConfigurationModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationModel
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ConfigurationModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationModel
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationModel
     */
    'isDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfigurationPostModel
 */
export interface ConfigurationPostModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationPostModel
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConfigurationPostModel
     */
    'capabilities': { [key: string]: string; };
    /**
     * This property is used to link configuration with project
     * @type {string}
     * @memberof ConfigurationPostModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationPostModel
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPostModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ConfigurationPutModel
 */
export interface ConfigurationPutModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationPutModel
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConfigurationPutModel
     */
    'capabilities': { [key: string]: string; };
    /**
     * This property is used to link configuration with project
     * @type {string}
     * @memberof ConfigurationPutModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationPutModel
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPutModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CustomAttributeModel
 */
export interface CustomAttributeModel {
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeModel
     */
    'id'?: string;
    /**
     * 
     * @type {Array<CustomAttributeOptionModel>}
     * @memberof CustomAttributeModel
     */
    'options'?: Array<CustomAttributeOptionModel> | null;
    /**
     * 
     * @type {CustomAttributeTypesEnum}
     * @memberof CustomAttributeModel
     */
    'type': CustomAttributeTypesEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeModel
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeModel
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeModel
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeModel
     */
    'isGlobal'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomAttributeOptionModel
 */
export interface CustomAttributeOptionModel {
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeOptionModel
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeOptionModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeOptionModel
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeOptionModel
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomAttributeOptionPostModel
 */
export interface CustomAttributeOptionPostModel {
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeOptionPostModel
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeOptionPostModel
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomAttributePostModel
 */
export interface CustomAttributePostModel {
    /**
     * 
     * @type {Array<CustomAttributeOptionPostModel>}
     * @memberof CustomAttributePostModel
     */
    'options'?: Array<CustomAttributeOptionPostModel> | null;
    /**
     * 
     * @type {CustomAttributeTypesEnum}
     * @memberof CustomAttributePostModel
     */
    'type': CustomAttributeTypesEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomAttributePostModel
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributePostModel
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributePostModel
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributePostModel
     */
    'isGlobal'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomAttributeTestPlanProjectRelationPutModel
 */
export interface CustomAttributeTestPlanProjectRelationPutModel {
    /**
     * 
     * @type {string}
     * @memberof CustomAttributeTestPlanProjectRelationPutModel
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeTestPlanProjectRelationPutModel
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomAttributeTestPlanProjectRelationPutModel
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CustomAttributeTypesEnum = {
    String: 'string',
    Datetime: 'datetime',
    Options: 'options',
    User: 'user',
    MultipleOptions: 'multipleOptions'
} as const;

export type CustomAttributeTypesEnum = typeof CustomAttributeTypesEnum[keyof typeof CustomAttributeTypesEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ImageResizeOption = {
    Crop: 'Crop',
    AddBackgroundStripes: 'AddBackgroundStripes'
} as const;

export type ImageResizeOption = typeof ImageResizeOption[keyof typeof ImageResizeOption];


/**
 * 
 * @export
 * @interface IterationModel
 */
export interface IterationModel {
    /**
     * 
     * @type {string}
     * @memberof IterationModel
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ParameterShortModel>}
     * @memberof IterationModel
     */
    'parameters'?: Array<ParameterShortModel> | null;
}
/**
 * 
 * @export
 * @interface IterationPutModel
 */
export interface IterationPutModel {
    /**
     * 
     * @type {Array<ParameterIterationModel>}
     * @memberof IterationPutModel
     */
    'parameters': Array<ParameterIterationModel>;
    /**
     * 
     * @type {string}
     * @memberof IterationPutModel
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LabelPostModel
 */
export interface LabelPostModel {
    /**
     * 
     * @type {string}
     * @memberof LabelPostModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LabelShortModel
 */
export interface LabelShortModel {
    /**
     * 
     * @type {number}
     * @memberof LabelShortModel
     */
    'globalId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LabelShortModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LinkModel
 */
export interface LinkModel {
    /**
     * 
     * @type {string}
     * @memberof LinkModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinkModel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof LinkModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {LinkType}
     * @memberof LinkModel
     */
    'type'?: LinkType;
    /**
     * 
     * @type {boolean}
     * @memberof LinkModel
     */
    'hasInfo'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkPostModel
 */
export interface LinkPostModel {
    /**
     * 
     * @type {string}
     * @memberof LinkPostModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinkPostModel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof LinkPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {LinkType}
     * @memberof LinkPostModel
     */
    'type'?: LinkType;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPostModel
     */
    'hasInfo'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkPutModel
 */
export interface LinkPutModel {
    /**
     * 
     * @type {string}
     * @memberof LinkPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPutModel
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinkPutModel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof LinkPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {LinkType}
     * @memberof LinkPutModel
     */
    'type'?: LinkType;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPutModel
     */
    'hasInfo'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LinkType = {
    Related: 'Related',
    BlockedBy: 'BlockedBy',
    Defect: 'Defect',
    Issue: 'Issue',
    Requirement: 'Requirement',
    Repository: 'Repository'
} as const;

export type LinkType = typeof LinkType[keyof typeof LinkType];


/**
 * 
 * @export
 * @interface ParameterIterationModel
 */
export interface ParameterIterationModel {
    /**
     * 
     * @type {string}
     * @memberof ParameterIterationModel
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ParameterModel
 */
export interface ParameterModel {
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParameterModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'parameterKeyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ParameterModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ParameterPostModel
 */
export interface ParameterPostModel {
    /**
     * 
     * @type {string}
     * @memberof ParameterPostModel
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ParameterPostModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ParameterPutModel
 */
export interface ParameterPutModel {
    /**
     * 
     * @type {string}
     * @memberof ParameterPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterPutModel
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ParameterPutModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ParameterShortModel
 */
export interface ParameterShortModel {
    /**
     * 
     * @type {string}
     * @memberof ParameterShortModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterShortModel
     */
    'parameterKeyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterShortModel
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ParameterShortModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface ProjectExportQueryModel
 */
export interface ProjectExportQueryModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectExportQueryModel
     */
    'sectionIds'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectExportQueryModel
     */
    'workItemIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ProjectExportWithTestPlansPostModel
 */
export interface ProjectExportWithTestPlansPostModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectExportWithTestPlansPostModel
     */
    'testPlansIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ProjectModel
 */
export interface ProjectModel {
    /**
     * 
     * @type {Array<CustomAttributeModel>}
     * @memberof ProjectModel
     */
    'attributesScheme'?: Array<CustomAttributeModel> | null;
    /**
     * 
     * @type {Array<CustomAttributeModel>}
     * @memberof ProjectModel
     */
    'testPlansAttributesScheme'?: Array<CustomAttributeModel> | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectModel
     */
    'testCasesCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectModel
     */
    'sharedStepsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectModel
     */
    'checkListsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectModel
     */
    'autoTestsCount'?: number | null;
    /**
     * Property is used to filter favourite projects
     * @type {boolean}
     * @memberof ProjectModel
     */
    'isFavorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectPostModel
 */
export interface ProjectPostModel {
    /**
     * 
     * @type {string}
     * @memberof ProjectPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectPostModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectPutModel
 */
export interface ProjectPutModel {
    /**
     * 
     * @type {string}
     * @memberof ProjectPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectPutModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SectionModel
 */
export interface SectionModel {
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SectionModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SectionMoveModel
 */
export interface SectionMoveModel {
    /**
     * 
     * @type {string}
     * @memberof SectionMoveModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SectionMoveModel
     */
    'oldParentId': string;
    /**
     * 
     * @type {string}
     * @memberof SectionMoveModel
     */
    'parentId': string;
    /**
     * Used for section rank set
     * @type {string}
     * @memberof SectionMoveModel
     */
    'nextSectionId'?: string | null;
}
/**
 * 
 * @export
 * @interface SectionPostModel
 */
export interface SectionPostModel {
    /**
     * 
     * @type {string}
     * @memberof SectionPostModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SectionPostModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof SectionPostModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof SectionPostModel
     */
    'preconditionSteps'?: Array<StepPutModel> | null;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof SectionPostModel
     */
    'postconditionSteps'?: Array<StepPutModel> | null;
}
/**
 * 
 * @export
 * @interface SectionPutModel
 */
export interface SectionPutModel {
    /**
     * 
     * @type {string}
     * @memberof SectionPutModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SectionPutModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SectionPutModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof SectionPutModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof SectionPutModel
     */
    'preconditionSteps'?: Array<StepPutModel> | null;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof SectionPutModel
     */
    'postconditionSteps'?: Array<StepPutModel> | null;
}
/**
 * 
 * @export
 * @interface SectionRenameModel
 */
export interface SectionRenameModel {
    /**
     * 
     * @type {string}
     * @memberof SectionRenameModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SectionRenameModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SectionWithStepsModel
 */
export interface SectionWithStepsModel {
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof SectionWithStepsModel
     */
    'preconditionSteps'?: Array<StepModel> | null;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof SectionWithStepsModel
     */
    'postconditionSteps'?: Array<StepModel> | null;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SectionWithStepsModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SectionWithStepsModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SharedStepModel
 */
export interface SharedStepModel {
    /**
     * 
     * @type {string}
     * @memberof SharedStepModel
     */
    'versionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SharedStepModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SharedStepModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof SharedStepModel
     * @deprecated
     */
    'steps'?: Array<StepModel> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SharedStepModel
     */
    'isDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface StepModel
 */
export interface StepModel {
    /**
     * 
     * @type {SharedStepModel}
     * @memberof StepModel
     */
    'workItem'?: SharedStepModel;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'action'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'expected'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'testData'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'comments'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'workItemId'?: string | null;
}
/**
 * 
 * @export
 * @interface StepPutModel
 */
export interface StepPutModel {
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'action'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'expected'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'testData'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'comments'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StepPutModel
     */
    'workItemId'?: string | null;
}
/**
 * 
 * @export
 * @interface TagShortModel
 */
export interface TagShortModel {
    /**
     * 
     * @type {string}
     * @memberof TagShortModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TestPlanModel
 */
export interface TestPlanModel {
    /**
     * 
     * @type {TestPlanStatusModel}
     * @memberof TestPlanModel
     */
    'status'?: TestPlanStatusModel;
    /**
     * Set when test plan is starter (status changed to: In Progress)
     * @type {string}
     * @memberof TestPlanModel
     */
    'startedOn'?: string | null;
    /**
     * set when test plan status is completed (status changed to: Completed)
     * @type {string}
     * @memberof TestPlanModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'modifiedById'?: string | null;
    /**
     * Used for search Test plan
     * @type {number}
     * @memberof TestPlanModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TestPlanModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'lockedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'lockedById'?: string | null;
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof TestPlanModel
     */
    'tags'?: Array<TagShortModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'name': string;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanModel
     */
    'startDate'?: string | null;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanModel
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'build'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanModel
     */
    'productName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TestPlanModel
     */
    'hasAutomaticDurationTimer'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TestPlanModel
     */
    'attributes'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface TestPlanPostModel
 */
export interface TestPlanPostModel {
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof TestPlanPostModel
     */
    'tags'?: Array<TagShortModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'name': string;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'startDate'?: string | null;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'build'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPostModel
     */
    'productName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TestPlanPostModel
     */
    'hasAutomaticDurationTimer'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TestPlanPostModel
     */
    'attributes'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface TestPlanPutModel
 */
export interface TestPlanPutModel {
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'lockedById'?: string | null;
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof TestPlanPutModel
     */
    'tags'?: Array<TagShortModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'name': string;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'startDate'?: string | null;
    /**
     * Used for analytics
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'build'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof TestPlanPutModel
     */
    'productName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TestPlanPutModel
     */
    'hasAutomaticDurationTimer'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TestPlanPutModel
     */
    'attributes'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TestPlanStatusModel = {
    New: 'New',
    InProgress: 'InProgress',
    Paused: 'Paused',
    Completed: 'Completed'
} as const;

export type TestPlanStatusModel = typeof TestPlanStatusModel[keyof typeof TestPlanStatusModel];


/**
 * 
 * @export
 * @interface TestPointByTestSuiteModel
 */
export interface TestPointByTestSuiteModel {
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'testerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'workItemId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'configurationId'?: string | null;
    /**
     * Applies one of these values: Blocked, NoResults, Failed, Passed
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'lastTestResultId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointByTestSuiteModel
     */
    'iterationId'?: string;
}
/**
 * 
 * @export
 * @interface TestPointSelector
 */
export interface TestPointSelector {
    /**
     * 
     * @type {string}
     * @memberof TestPointSelector
     */
    'configurationId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestPointSelector
     */
    'workitemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface TestPointShortModel
 */
export interface TestPointShortModel {
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'testSuiteId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'testerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'workItemId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'configurationId'?: string | null;
    /**
     * Applies one of these values: Blocked, NoResults, Failed, Passed
     * @type {string}
     * @memberof TestPointShortModel
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'lastTestResultId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestPointShortModel
     */
    'iterationId'?: string;
}
/**
 * 
 * @export
 * @interface TestResultChronologyModel
 */
export interface TestResultChronologyModel {
    /**
     * 
     * @type {string}
     * @memberof TestResultChronologyModel
     */
    'outcome'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TestResultChronologyModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface TestResultHistoryReportModel
 */
export interface TestResultHistoryReportModel {
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'modifiedDate'?: string;
    /**
     * If test run was stopped, this property equals identifier of user who stopped it.Otherwise, the property equals identifier of user who created the test result
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'testRunId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'testRunName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'createdByUserName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'testPlanId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TestResultHistoryReportModel
     */
    'testPlanGlobalId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'testPlanName'?: string | null;
    /**
     * If test point related to the test result has configuration, this property will be equal to the test point configuration name. Otherwise, this property will be equal to the test result configuration name
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'configurationName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TestResultHistoryReportModel
     */
    'isAutomated'?: boolean;
    /**
     * If any test result related to the test run is linked with autotest and the run has an outcome, the outcome value equalsto the worst outcome of the last modified test result.Otherwise, the outcome equals to the outcome of first created test result in the test run
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'outcome'?: string | null;
    /**
     * If any test result related to the test run is linked with autotest, comment will have default valueOtherwise, the comment equals to the comment of first created test result in the test run
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'comment'?: string | null;
    /**
     * If any test result related to the test run is linked with autotest, link will be equal to the links of last modified test result.Otherwise, the links equals to the links of first created test result in the test run
     * @type {Array<LinkModel>}
     * @memberof TestResultHistoryReportModel
     */
    'links'?: Array<LinkModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TestResultHistoryReportModel
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'modifiedById'?: string | null;
    /**
     * If any test result related to the test run is linked with autotest, attachments will be equal to the attachments of last modified test result.Otherwise, the attachments equals to the attachments of first created test result in the test run
     * @type {Array<AttachmentModel>}
     * @memberof TestResultHistoryReportModel
     */
    'attachments'?: Array<AttachmentModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'workItemVersionId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TestResultHistoryReportModel
     */
    'workItemVersionNumber'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultHistoryReportModel
     */
    'launchSource'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestResultHistoryReportModel
     */
    'failureClassIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface TestResultV2GetModel
 */
export interface TestResultV2GetModel {
    /**
     * 
     * @type {ConfigurationModel}
     * @memberof TestResultV2GetModel
     */
    'configuration'?: ConfigurationModel;
    /**
     * 
     * @type {AutoTestModelV2GetModel}
     * @memberof TestResultV2GetModel
     */
    'autoTest'?: AutoTestModelV2GetModel;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'configurationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'workItemVersionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'autoTestId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'traces'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'runByUserId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'stoppedByUserId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'testPointId'?: string | null;
    /**
     * 
     * @type {TestPointShortModel}
     * @memberof TestResultV2GetModel
     */
    'testPoint'?: TestPointShortModel;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'testRunId'?: string;
    /**
     * Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'outcome'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2GetModel
     */
    'comment'?: string | null;
    /**
     * 
     * @type {Array<LinkModel>}
     * @memberof TestResultV2GetModel
     */
    'links'?: Array<LinkModel> | null;
    /**
     * 
     * @type {Array<AttachmentModel>}
     * @memberof TestResultV2GetModel
     */
    'attachments'?: Array<AttachmentModel> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestResultV2GetModel
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestResultV2GetModel
     */
    'properties'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface TestResultV2ShortModel
 */
export interface TestResultV2ShortModel {
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'configurationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'workItemVersionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'autoTestId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'traces'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'runByUserId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'stoppedByUserId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'testPointId'?: string | null;
    /**
     * 
     * @type {TestPointShortModel}
     * @memberof TestResultV2ShortModel
     */
    'testPoint'?: TestPointShortModel;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'testRunId'?: string;
    /**
     * Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'outcome'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestResultV2ShortModel
     */
    'comment'?: string | null;
    /**
     * 
     * @type {Array<LinkModel>}
     * @memberof TestResultV2ShortModel
     */
    'links'?: Array<LinkModel> | null;
    /**
     * 
     * @type {Array<AttachmentModel>}
     * @memberof TestResultV2ShortModel
     */
    'attachments'?: Array<AttachmentModel> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestResultV2ShortModel
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestResultV2ShortModel
     */
    'properties'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface TestRunFillByAutoTestsPostModel
 */
export interface TestRunFillByAutoTestsPostModel {
    /**
     * This property is used to link test run with project
     * @type {string}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'configurationIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'autoTestExternalIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByAutoTestsPostModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestRunFillByConfigurationsPostModel
 */
export interface TestRunFillByConfigurationsPostModel {
    /**
     * 
     * @type {Array<TestPointSelector>}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'testPointSelectors': Array<TestPointSelector>;
    /**
     * This property is used to link test run with project
     * @type {string}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'projectId': string;
    /**
     * This property is used to link test run with test plan
     * @type {string}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'testPlanId': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByConfigurationsPostModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestRunFillByWorkItemsPostModel
 */
export interface TestRunFillByWorkItemsPostModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'configurationIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'workitemIds': Array<string>;
    /**
     * This property is used to link test run with project
     * @type {string}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'projectId': string;
    /**
     * This property is used to link test run with test plan
     * @type {string}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'testPlanId': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunFillByWorkItemsPostModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestRunShortModel
 */
export interface TestRunShortModel {
    /**
     * 
     * @type {TestRunStateTypeModel}
     * @memberof TestRunShortModel
     */
    'stateName'?: TestRunStateTypeModel;
    /**
     * 
     * @type {string}
     * @memberof TestRunShortModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestRunShortModel
     */
    'testPlanId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunShortModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunShortModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunShortModel
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TestRunShortModel
     */
    'isDeleted'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TestRunStateTypeModel = {
    NotStarted: 'NotStarted',
    InProgress: 'InProgress',
    Stopped: 'Stopped',
    Completed: 'Completed'
} as const;

export type TestRunStateTypeModel = typeof TestRunStateTypeModel[keyof typeof TestRunStateTypeModel];


/**
 * 
 * @export
 * @interface TestRunV2GetModel
 */
export interface TestRunV2GetModel {
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'startedOn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'completedOn'?: string | null;
    /**
     * 
     * @type {TestRunStateTypeModel}
     * @memberof TestRunV2GetModel
     */
    'stateName'?: TestRunStateTypeModel;
    /**
     * This property is used to link test run with project
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'projectId'?: string;
    /**
     * This property is used to link test run with test plan
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'testPlanId'?: string | null;
    /**
     * 
     * @type {Array<TestResultV2GetModel>}
     * @memberof TestRunV2GetModel
     */
    'testResults'?: Array<TestResultV2GetModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'createdByUserName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'description'?: string | null;
    /**
     * Once launch source is specified it cannot be updated
     * @type {string}
     * @memberof TestRunV2GetModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestRunV2PostShortModel
 */
export interface TestRunV2PostShortModel {
    /**
     * This property is to link test run with a project
     * @type {string}
     * @memberof TestRunV2PostShortModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PostShortModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PostShortModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PostShortModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestRunV2PutModel
 */
export interface TestRunV2PutModel {
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PutModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PutModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TestRunV2PutModel
     */
    'description'?: string | null;
    /**
     * Once launch source is specified it cannot be updated
     * @type {string}
     * @memberof TestRunV2PutModel
     */
    'launchSource'?: string | null;
}
/**
 * 
 * @export
 * @interface TestSuiteV2GetModel
 */
export interface TestSuiteV2GetModel {
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2GetModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2GetModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2GetModel
     */
    'testPlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2GetModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TestSuiteV2PostModel
 */
export interface TestSuiteV2PostModel {
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PostModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PostModel
     */
    'testPlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PostModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TestSuiteV2PutModel
 */
export interface TestSuiteV2PutModel {
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PutModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2PutModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TestSuiteV2TreeModel
 */
export interface TestSuiteV2TreeModel {
    /**
     * nested enumeration of children is allowed
     * @type {Array<TestSuiteV2TreeModel>}
     * @memberof TestSuiteV2TreeModel
     * @deprecated
     */
    'children'?: Array<TestSuiteV2TreeModel> | null;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2TreeModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2TreeModel
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2TreeModel
     */
    'testPlanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteV2TreeModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkItemEntityTypes = {
    TestCases: 'TestCases',
    CheckLists: 'CheckLists',
    SharedSteps: 'SharedSteps'
} as const;

export type WorkItemEntityTypes = typeof WorkItemEntityTypes[keyof typeof WorkItemEntityTypes];


/**
 * 
 * @export
 * @interface WorkItemExtractionModel
 */
export interface WorkItemExtractionModel {
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'includeWorkItems'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'includeSections'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'includeProjects'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'excludeWorkItems'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'excludeSections'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemExtractionModel
     */
    'excludeProjects'?: Set<string>;
}
/**
 * 
 * @export
 * @interface WorkItemFilterModel
 */
export interface WorkItemFilterModel {
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'nameOrId'?: string | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'includeIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'excludeIds'?: Set<string> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'name'?: string | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof WorkItemFilterModel
     */
    'globalIds'?: Set<number> | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof WorkItemFilterModel
     */
    'attributes'?: { [key: string]: Array<string>; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemFilterModel
     */
    'isDeleted'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'projectIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'sectionIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'createdByIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'modifiedByIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<WorkItemStates>}
     * @memberof WorkItemFilterModel
     */
    'states'?: Set<WorkItemStates> | null;
    /**
     * 
     * @type {Set<WorkItemPriorityModel>}
     * @memberof WorkItemFilterModel
     */
    'priorities'?: Set<WorkItemPriorityModel> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'entityTypes'?: Set<string> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'createdDateMinimal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'createdDateMaximal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'modifiedDateMinimal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemFilterModel
     */
    'modifiedDateMaximal'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkItemFilterModel
     */
    'durationMinimal'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WorkItemFilterModel
     */
    'durationMaximal'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemFilterModel
     */
    'isAutomated'?: boolean | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'tagNames'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     */
    'autoTestIds'?: Set<string> | null;
    /**
     * 
     * @type {Set<string>}
     * @memberof WorkItemFilterModel
     * @deprecated
     */
    'exceptWorkItemIds'?: Set<string> | null;
}
/**
 * 
 * @export
 * @interface WorkItemIdModel
 */
export interface WorkItemIdModel {
    /**
     * Used for search WorkItem. Internal identifier has a Guid data format. Global identifier has an integer data format
     * @type {string}
     * @memberof WorkItemIdModel
     */
    'id'?: string | null;
}
/**
 * 
 * @export
 * @interface WorkItemModel
 */
export interface WorkItemModel {
    /**
     * used for versioning changes in workitem
     * @type {string}
     * @memberof WorkItemModel
     */
    'versionId'?: string;
    /**
     * used for getting a median duration of all autotests related to this workitem
     * @type {number}
     * @memberof WorkItemModel
     */
    'medianDuration'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'projectId'?: string;
    /**
     * 
     * @type {WorkItemEntityTypes}
     * @memberof WorkItemModel
     */
    'entityTypeName': WorkItemEntityTypes;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemModel
     */
    'isAutomated'?: boolean;
    /**
     * 
     * @type {Array<AutoTestModel>}
     * @memberof WorkItemModel
     */
    'autoTests'?: Array<AutoTestModel> | null;
    /**
     * 
     * @type {Array<AttachmentModel>}
     * @memberof WorkItemModel
     */
    'attachments'?: Array<AttachmentModel> | null;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof WorkItemModel
     */
    'sectionPreconditionSteps'?: Array<StepModel> | null;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof WorkItemModel
     */
    'sectionPostconditionSteps'?: Array<StepModel> | null;
    /**
     * used for define chronology of workitem state in each version
     * @type {number}
     * @memberof WorkItemModel
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {Array<IterationModel>}
     * @memberof WorkItemModel
     */
    'iterations'?: Array<IterationModel> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkItemModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'sectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {WorkItemStates}
     * @memberof WorkItemModel
     */
    'state': WorkItemStates;
    /**
     * 
     * @type {WorkItemPriorityModel}
     * @memberof WorkItemModel
     */
    'priority': WorkItemPriorityModel;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof WorkItemModel
     */
    'steps': Array<StepModel>;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof WorkItemModel
     */
    'preconditionSteps': Array<StepModel>;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof WorkItemModel
     */
    'postconditionSteps': Array<StepModel>;
    /**
     * 
     * @type {number}
     * @memberof WorkItemModel
     */
    'duration'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemModel
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof WorkItemModel
     */
    'tags': Array<TagShortModel>;
    /**
     * 
     * @type {Array<LinkModel>}
     * @memberof WorkItemModel
     */
    'links': Array<LinkModel>;
    /**
     * 
     * @type {string}
     * @memberof WorkItemModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkItemPostModel
 */
export interface WorkItemPostModel {
    /**
     * 
     * @type {WorkItemEntityTypes}
     * @memberof WorkItemPostModel
     */
    'entityTypeName': WorkItemEntityTypes;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPostModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {WorkItemStates}
     * @memberof WorkItemPostModel
     */
    'state': WorkItemStates;
    /**
     * 
     * @type {WorkItemPriorityModel}
     * @memberof WorkItemPostModel
     */
    'priority': WorkItemPriorityModel;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPostModel
     */
    'steps': Array<StepPutModel>;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPostModel
     */
    'preconditionSteps': Array<StepPutModel>;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPostModel
     */
    'postconditionSteps': Array<StepPutModel>;
    /**
     * Must be 0 for shared steps and greater than 0 for the other types of work items
     * @type {number}
     * @memberof WorkItemPostModel
     */
    'duration': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemPostModel
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof WorkItemPostModel
     */
    'tags': Array<TagShortModel>;
    /**
     * 
     * @type {Array<AttachmentPutModel>}
     * @memberof WorkItemPostModel
     */
    'attachments'?: Array<AttachmentPutModel> | null;
    /**
     * 
     * @type {Array<IterationPutModel>}
     * @memberof WorkItemPostModel
     */
    'iterations'?: Array<IterationPutModel> | null;
    /**
     * 
     * @type {Array<LinkPostModel>}
     * @memberof WorkItemPostModel
     */
    'links': Array<LinkPostModel>;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPostModel
     */
    'name': string;
    /**
     * This property is used to link workitem with project
     * @type {string}
     * @memberof WorkItemPostModel
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPostModel
     */
    'sectionId': string;
    /**
     * 
     * @type {Array<AutoTestIdModel>}
     * @memberof WorkItemPostModel
     */
    'autoTests'?: Array<AutoTestIdModel> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkItemPriorityModel = {
    Lowest: 'Lowest',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Highest: 'Highest'
} as const;

export type WorkItemPriorityModel = typeof WorkItemPriorityModel[keyof typeof WorkItemPriorityModel];


/**
 * 
 * @export
 * @interface WorkItemPutModel
 */
export interface WorkItemPutModel {
    /**
     * 
     * @type {Array<AttachmentPutModel>}
     * @memberof WorkItemPutModel
     */
    'attachments': Array<AttachmentPutModel>;
    /**
     * 
     * @type {Array<IterationPutModel>}
     * @memberof WorkItemPutModel
     */
    'iterations'?: Array<IterationPutModel> | null;
    /**
     * 
     * @type {Array<AutoTestIdModel>}
     * @memberof WorkItemPutModel
     */
    'autoTests'?: Array<AutoTestIdModel> | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPutModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPutModel
     */
    'sectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPutModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {WorkItemStates}
     * @memberof WorkItemPutModel
     */
    'state': WorkItemStates;
    /**
     * 
     * @type {WorkItemPriorityModel}
     * @memberof WorkItemPutModel
     */
    'priority': WorkItemPriorityModel;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPutModel
     */
    'steps': Array<StepPutModel>;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPutModel
     */
    'preconditionSteps': Array<StepPutModel>;
    /**
     * 
     * @type {Array<StepPutModel>}
     * @memberof WorkItemPutModel
     */
    'postconditionSteps': Array<StepPutModel>;
    /**
     * 
     * @type {number}
     * @memberof WorkItemPutModel
     */
    'duration'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemPutModel
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<TagShortModel>}
     * @memberof WorkItemPutModel
     */
    'tags': Array<TagShortModel>;
    /**
     * 
     * @type {Array<LinkPutModel>}
     * @memberof WorkItemPutModel
     */
    'links': Array<LinkPutModel>;
    /**
     * 
     * @type {string}
     * @memberof WorkItemPutModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkItemSelectModel
 */
export interface WorkItemSelectModel {
    /**
     * 
     * @type {WorkItemFilterModel}
     * @memberof WorkItemSelectModel
     */
    'filter'?: WorkItemFilterModel;
    /**
     * 
     * @type {WorkItemExtractionModel}
     * @memberof WorkItemSelectModel
     */
    'extractionModel'?: WorkItemExtractionModel;
}
/**
 * 
 * @export
 * @interface WorkItemShortModel
 */
export interface WorkItemShortModel {
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'id'?: string;
    /**
     * used for versioning changes in workitem
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'versionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'name': string;
    /**
     * Property can have one of these values: CheckLists, SharedSteps, TestCases
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'entityTypeName': string;
    /**
     * This property is used to link autotest with project
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'projectId': string;
    /**
     * This property links workitem with section
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'sectionId': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemShortModel
     */
    'isAutomated'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkItemShortModel
     */
    'globalId'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkItemShortModel
     */
    'duration'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemShortModel
     */
    'attributes'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'modifiedById'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'createdDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'modifiedDate'?: string | null;
    /**
     * Property can have one of these values: NeedsWork, NotReady, Ready
     * @type {string}
     * @memberof WorkItemShortModel
     */
    'state': string;
    /**
     * 
     * @type {WorkItemPriorityModel}
     * @memberof WorkItemShortModel
     */
    'priority': WorkItemPriorityModel;
    /**
     * 
     * @type {boolean}
     * @memberof WorkItemShortModel
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkItemShortModel
     */
    'tagNames'?: Array<string> | null;
    /**
     * 
     * @type {Array<IterationModel>}
     * @memberof WorkItemShortModel
     */
    'iterations'?: Array<IterationModel> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkItemStates = {
    NeedsWork: 'NeedsWork',
    NotReady: 'NotReady',
    Ready: 'Ready'
} as const;

export type WorkItemStates = typeof WorkItemStates[keyof typeof WorkItemStates];


/**
 * 
 * @export
 * @interface WorkItemVersionModel
 */
export interface WorkItemVersionModel {
    /**
     * used for versioning changes in workitem
     * @type {string}
     * @memberof WorkItemVersionModel
     */
    'versionId'?: string;
    /**
     * used for define chronology of workitem state in each version
     * @type {number}
     * @memberof WorkItemVersionModel
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkItemVersionModel
     */
    'modifiedDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkItemVersionModel
     */
    'modifiedById'?: string | null;
}

/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User send file  <br>User runs method execution  <br>System upload file  <br>System create attachment  <br>System return attachment model (listed in response parameters)
         * @summary Create attachment
         * @param {string} [apiVersion] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment: async (apiVersion?: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (apiVersion !== undefined) {
                localVarQueryParameter['apiVersion'] = apiVersion;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User send file  <br>User runs method execution  <br>System upload file  <br>System create attachment  <br>System return attachment model (listed in response parameters)
         * @summary Create attachment
         * @param {string} [apiVersion] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttachment(apiVersion?: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttachment(apiVersion, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User send file  <br>User runs method execution  <br>System upload file  <br>System create attachment  <br>System return attachment model (listed in response parameters)
         * @summary Create attachment
         * @param {string} [apiVersion] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(apiVersion?: string, file?: File, options?: any): AxiosPromise<string> {
            return localVarFp.addAttachment(apiVersion, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User send file  <br>User runs method execution  <br>System upload file  <br>System create attachment  <br>System return attachment model (listed in response parameters)
     * @summary Create attachment
     * @param {string} [apiVersion] 
     * @param {File} [file] Select file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public addAttachment(apiVersion?: string, file?: File, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).addAttachment(apiVersion, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutoTestsApi - axios parameter creator
 * @export
 */
export const AutoTestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTest
         * @param {AutoTestPostModel} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoTest: async (autoTestPostModel?: AutoTestPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/autoTests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTests multiple
         * @param {Array<AutoTestPostModel>} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiple: async (autoTestPostModel?: Array<AutoTestPostModel>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/autoTests/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System deletes autotest and returns no content response
         * @summary Delete AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier \&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoTest: async (autoTestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('deleteAutoTest', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>[Optional] User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>                      [Optional] if workitem id is set by User, System finds the workitem by the workitem identifier and unlinks it                      from autotest.                    <br>[Optional] Otherwise, if workitem id is not specified, System unlinks all workitems linked to autotest.  <br>System returns no content response
         * @summary Delete AutoTest link from WorkItem by Id or GlobalId  (if workItemId is not specified, then remove all links WorkItems to AutoTest)
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [workItemId] workItem internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoTestLinkFromWorkItem: async (autoTestId: string, workItemId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('deleteAutoTestLinkFromWorkItem', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/workItems`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workItemId !== undefined) {
                localVarQueryParameter['workItemId'] = workItemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>[Optional] User sets search parameters (listed in request parameters) and runs method execution  <br>System returns all autotests, matching search criteria
         * @summary Get all AutoTests (if parameters are specified, then it\'s filtered by them.)
         * @param {string} [projectId] Project internal identifier
         * @param {string} [externalId] Autotest external identifier
         * @param {number} [globalId] Autotest global identifier
         * @param {string} [namespace] Name of abstract storage where autotest is located
         * @param {boolean} [isNamespaceNull] Boolean flag which defines if search must include autotests with null  value Namespace attribute
         * @param {string} [classname] Name of the class where autotest is located
         * @param {boolean} [isClassnameNull] Boolean flag which defines if search must include autotests with null  value Classname attribute
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted autotests
         * @param {Array<string>} [labels] List of autotests labels to filter by
         * @param {number} [stabilityMinimal] Minimal stability value to filter by
         * @param {number} [stabilityMaximal] Maximal stability value to filter by
         * @param {boolean} [isFlaky] [Optional] If flaky is set
         * @param {boolean} [includeSteps] Boolean flag which defines if setup, steps and teardown fields must be included
         * @param {boolean} [includeLabels] Boolean flag which defines if labels field must be included
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAutoTests: async (projectId?: string, externalId?: string, globalId?: number, namespace?: string, isNamespaceNull?: boolean, classname?: string, isClassnameNull?: boolean, isDeleted?: boolean, labels?: Array<string>, stabilityMinimal?: number, stabilityMaximal?: number, isFlaky?: boolean, includeSteps?: boolean, includeLabels?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/autoTests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['externalId'] = externalId;
            }

            if (globalId !== undefined) {
                localVarQueryParameter['globalId'] = globalId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['Namespace'] = namespace;
            }

            if (isNamespaceNull !== undefined) {
                localVarQueryParameter['isNamespaceNull'] = isNamespaceNull;
            }

            if (classname !== undefined) {
                localVarQueryParameter['classname'] = classname;
            }

            if (isClassnameNull !== undefined) {
                localVarQueryParameter['isClassnameNull'] = isClassnameNull;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (stabilityMinimal !== undefined) {
                localVarQueryParameter['stabilityMinimal'] = stabilityMinimal;
            }

            if (stabilityMaximal !== undefined) {
                localVarQueryParameter['stabilityMaximal'] = stabilityMaximal;
            }

            if (isFlaky !== undefined) {
                localVarQueryParameter['isFlaky'] = isFlaky;
            }

            if (includeSteps !== undefined) {
                localVarQueryParameter['includeSteps'] = includeSteps;
            }

            if (includeLabels !== undefined) {
                localVarQueryParameter['includeLabels'] = includeLabels;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System calculates pass average duration and fail average duration of autotest from all related test results  <br>System returns pass average duration and fail average duration for autotest
         * @summary Get AutoTest average duration by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestAverageDuration: async (autoTestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getAutoTestAverageDuration', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/averageDuration`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal or global identifier and runs method execution  <br>                      System returns autotest, which internal or global identifier equals the identifier value set in the previous                      action                  
         * @summary Get AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal identifier (guid format) or  global identifier (integer format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestById: async (autoTestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getAutoTestById', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search all test results related to autotest (with default limit equal 100)  <br>                      System orders the test results by CompletedOn property descending and then orders by CreatedDate property                      descending                    <br>System returns test result chronology for autotest
         * @summary Get AutoTest chronology by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestChronology: async (autoTestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getAutoTestChronology', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/chronology`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search for all test runs related to the autotest  <br>System returns the enumeration of test runs
         * @summary Stopped and completed TestRuns which contain AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRuns: async (autoTestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getTestRuns', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/testRuns`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets getTestResultHistoryReportQuery (listed in the example)  <br>User runs method execution  <br>System search for test results using filters set by user in getTestResultHistoryReportQuery and autoTestId  <br>System returns the enumeration of test results
         * @summary History of TestResults for AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {Array<string>} [configurationIds] 
         * @param {Array<string>} [testPlanIds] 
         * @param {Array<string>} [userIds] 
         * @param {Array<string>} [outcomes] 
         * @param {boolean} [isAutomated] 
         * @param {Array<string>} [testRunIds] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemResults: async (autoTestId: string, from?: string, to?: string, configurationIds?: Array<string>, testPlanIds?: Array<string>, userIds?: Array<string>, outcomes?: Array<string>, isAutomated?: boolean, testRunIds?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getWorkItemResults', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/testResultHistory`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['From'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (configurationIds) {
                localVarQueryParameter['ConfigurationIds'] = configurationIds;
            }

            if (testPlanIds) {
                localVarQueryParameter['TestPlanIds'] = testPlanIds;
            }

            if (userIds) {
                localVarQueryParameter['UserIds'] = userIds;
            }

            if (outcomes) {
                localVarQueryParameter['Outcomes'] = outcomes;
            }

            if (isAutomated !== undefined) {
                localVarQueryParameter['IsAutomated'] = isAutomated;
            }

            if (testRunIds) {
                localVarQueryParameter['TestRunIds'] = testRunIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System finds all actual and not deleted WorkItems related to the found autotest  <br>System returns the enumeration of WorkItems
         * @summary Get all WorkItems Ids linked to AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {boolean} [isWorkItemDeleted] Boolean flag which defines if search must include deleted worItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsLinkedToAutoTest: async (autoTestId: string, isWorkItemDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('getWorkItemsLinkedToAutoTest', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/workItems`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isWorkItemDeleted !== undefined) {
                localVarQueryParameter['isWorkItemDeleted'] = isWorkItemDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>System finds the workitem by the workitem identifier  <br>System relates the workitem with the autotest and returns no content response
         * @summary Link AutoTest to WorkItem by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {WorkItemIdModel} [workItemIdModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAutoTestToWorkItem: async (autoTestId: string, workItemIdModel?: WorkItemIdModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoTestId' is not null or undefined
            assertParamExists('linkAutoTestToWorkItem', 'autoTestId', autoTestId)
            const localVarPath = `/api/v2/autoTests/{autoTestId}/workItems`
                .replace(`{${"autoTestId"}}`, encodeURIComponent(String(autoTestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemIdModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTest
         * @param {AutoTestPutModel} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoTest: async (autoTestPutModel?: AutoTestPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/autoTests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTests multiple
         * @param {Array<AutoTestPutModel>} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiple: async (autoTestPutModel?: Array<AutoTestPutModel>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/autoTests/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoTestsApi - functional programming interface
 * @export
 */
export const AutoTestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoTestsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTest
         * @param {AutoTestPostModel} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoTest(autoTestPostModel?: AutoTestPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoTestModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoTest(autoTestPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTests multiple
         * @param {Array<AutoTestPostModel>} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMultiple(autoTestPostModel?: Array<AutoTestPostModel>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoTestModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMultiple(autoTestPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System deletes autotest and returns no content response
         * @summary Delete AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier \&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutoTest(autoTestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoTest(autoTestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>[Optional] User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>                      [Optional] if workitem id is set by User, System finds the workitem by the workitem identifier and unlinks it                      from autotest.                    <br>[Optional] Otherwise, if workitem id is not specified, System unlinks all workitems linked to autotest.  <br>System returns no content response
         * @summary Delete AutoTest link from WorkItem by Id or GlobalId  (if workItemId is not specified, then remove all links WorkItems to AutoTest)
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [workItemId] workItem internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutoTestLinkFromWorkItem(autoTestId: string, workItemId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoTestLinkFromWorkItem(autoTestId, workItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>[Optional] User sets search parameters (listed in request parameters) and runs method execution  <br>System returns all autotests, matching search criteria
         * @summary Get all AutoTests (if parameters are specified, then it\'s filtered by them.)
         * @param {string} [projectId] Project internal identifier
         * @param {string} [externalId] Autotest external identifier
         * @param {number} [globalId] Autotest global identifier
         * @param {string} [namespace] Name of abstract storage where autotest is located
         * @param {boolean} [isNamespaceNull] Boolean flag which defines if search must include autotests with null  value Namespace attribute
         * @param {string} [classname] Name of the class where autotest is located
         * @param {boolean} [isClassnameNull] Boolean flag which defines if search must include autotests with null  value Classname attribute
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted autotests
         * @param {Array<string>} [labels] List of autotests labels to filter by
         * @param {number} [stabilityMinimal] Minimal stability value to filter by
         * @param {number} [stabilityMaximal] Maximal stability value to filter by
         * @param {boolean} [isFlaky] [Optional] If flaky is set
         * @param {boolean} [includeSteps] Boolean flag which defines if setup, steps and teardown fields must be included
         * @param {boolean} [includeLabels] Boolean flag which defines if labels field must be included
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAutoTests(projectId?: string, externalId?: string, globalId?: number, namespace?: string, isNamespaceNull?: boolean, classname?: string, isClassnameNull?: boolean, isDeleted?: boolean, labels?: Array<string>, stabilityMinimal?: number, stabilityMaximal?: number, isFlaky?: boolean, includeSteps?: boolean, includeLabels?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoTestModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAutoTests(projectId, externalId, globalId, namespace, isNamespaceNull, classname, isClassnameNull, isDeleted, labels, stabilityMinimal, stabilityMaximal, isFlaky, includeSteps, includeLabels, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System calculates pass average duration and fail average duration of autotest from all related test results  <br>System returns pass average duration and fail average duration for autotest
         * @summary Get AutoTest average duration by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoTestAverageDuration(autoTestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoTestAverageDurationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoTestAverageDuration(autoTestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal or global identifier and runs method execution  <br>                      System returns autotest, which internal or global identifier equals the identifier value set in the previous                      action                  
         * @summary Get AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal identifier (guid format) or  global identifier (integer format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoTestById(autoTestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoTestModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoTestById(autoTestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search all test results related to autotest (with default limit equal 100)  <br>                      System orders the test results by CompletedOn property descending and then orders by CreatedDate property                      descending                    <br>System returns test result chronology for autotest
         * @summary Get AutoTest chronology by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoTestChronology(autoTestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResultChronologyModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoTestChronology(autoTestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search for all test runs related to the autotest  <br>System returns the enumeration of test runs
         * @summary Stopped and completed TestRuns which contain AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRuns(autoTestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestRunShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRuns(autoTestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets getTestResultHistoryReportQuery (listed in the example)  <br>User runs method execution  <br>System search for test results using filters set by user in getTestResultHistoryReportQuery and autoTestId  <br>System returns the enumeration of test results
         * @summary History of TestResults for AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {Array<string>} [configurationIds] 
         * @param {Array<string>} [testPlanIds] 
         * @param {Array<string>} [userIds] 
         * @param {Array<string>} [outcomes] 
         * @param {boolean} [isAutomated] 
         * @param {Array<string>} [testRunIds] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemResults(autoTestId: string, from?: string, to?: string, configurationIds?: Array<string>, testPlanIds?: Array<string>, userIds?: Array<string>, outcomes?: Array<string>, isAutomated?: boolean, testRunIds?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResultHistoryReportModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemResults(autoTestId, from, to, configurationIds, testPlanIds, userIds, outcomes, isAutomated, testRunIds, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System finds all actual and not deleted WorkItems related to the found autotest  <br>System returns the enumeration of WorkItems
         * @summary Get all WorkItems Ids linked to AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {boolean} [isWorkItemDeleted] Boolean flag which defines if search must include deleted worItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsLinkedToAutoTest(autoTestId: string, isWorkItemDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemIdModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsLinkedToAutoTest(autoTestId, isWorkItemDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>System finds the workitem by the workitem identifier  <br>System relates the workitem with the autotest and returns no content response
         * @summary Link AutoTest to WorkItem by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {WorkItemIdModel} [workItemIdModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkAutoTestToWorkItem(autoTestId: string, workItemIdModel?: WorkItemIdModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkAutoTestToWorkItem(autoTestId, workItemIdModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTest
         * @param {AutoTestPutModel} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutoTest(autoTestPutModel?: AutoTestPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutoTest(autoTestPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTests multiple
         * @param {Array<AutoTestPutModel>} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMultiple(autoTestPutModel?: Array<AutoTestPutModel>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMultiple(autoTestPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutoTestsApi - factory interface
 * @export
 */
export const AutoTestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoTestsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTest
         * @param {AutoTestPostModel} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoTest(autoTestPostModel?: AutoTestPostModel, options?: any): AxiosPromise<AutoTestModel> {
            return localVarFp.createAutoTest(autoTestPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
         * @summary Create AutoTests multiple
         * @param {Array<AutoTestPostModel>} [autoTestPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultiple(autoTestPostModel?: Array<AutoTestPostModel>, options?: any): AxiosPromise<Array<AutoTestModel>> {
            return localVarFp.createMultiple(autoTestPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System deletes autotest and returns no content response
         * @summary Delete AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier \&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoTest(autoTestId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAutoTest(autoTestId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>[Optional] User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>                      [Optional] if workitem id is set by User, System finds the workitem by the workitem identifier and unlinks it                      from autotest.                    <br>[Optional] Otherwise, if workitem id is not specified, System unlinks all workitems linked to autotest.  <br>System returns no content response
         * @summary Delete AutoTest link from WorkItem by Id or GlobalId  (if workItemId is not specified, then remove all links WorkItems to AutoTest)
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [workItemId] workItem internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoTestLinkFromWorkItem(autoTestId: string, workItemId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAutoTestLinkFromWorkItem(autoTestId, workItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>[Optional] User sets search parameters (listed in request parameters) and runs method execution  <br>System returns all autotests, matching search criteria
         * @summary Get all AutoTests (if parameters are specified, then it\'s filtered by them.)
         * @param {string} [projectId] Project internal identifier
         * @param {string} [externalId] Autotest external identifier
         * @param {number} [globalId] Autotest global identifier
         * @param {string} [namespace] Name of abstract storage where autotest is located
         * @param {boolean} [isNamespaceNull] Boolean flag which defines if search must include autotests with null  value Namespace attribute
         * @param {string} [classname] Name of the class where autotest is located
         * @param {boolean} [isClassnameNull] Boolean flag which defines if search must include autotests with null  value Classname attribute
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted autotests
         * @param {Array<string>} [labels] List of autotests labels to filter by
         * @param {number} [stabilityMinimal] Minimal stability value to filter by
         * @param {number} [stabilityMaximal] Maximal stability value to filter by
         * @param {boolean} [isFlaky] [Optional] If flaky is set
         * @param {boolean} [includeSteps] Boolean flag which defines if setup, steps and teardown fields must be included
         * @param {boolean} [includeLabels] Boolean flag which defines if labels field must be included
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAutoTests(projectId?: string, externalId?: string, globalId?: number, namespace?: string, isNamespaceNull?: boolean, classname?: string, isClassnameNull?: boolean, isDeleted?: boolean, labels?: Array<string>, stabilityMinimal?: number, stabilityMaximal?: number, isFlaky?: boolean, includeSteps?: boolean, includeLabels?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<AutoTestModel>> {
            return localVarFp.getAllAutoTests(projectId, externalId, globalId, namespace, isNamespaceNull, classname, isClassnameNull, isDeleted, labels, stabilityMinimal, stabilityMaximal, isFlaky, includeSteps, includeLabels, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System calculates pass average duration and fail average duration of autotest from all related test results  <br>System returns pass average duration and fail average duration for autotest
         * @summary Get AutoTest average duration by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestAverageDuration(autoTestId: string, options?: any): AxiosPromise<AutoTestAverageDurationModel> {
            return localVarFp.getAutoTestAverageDuration(autoTestId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal or global identifier and runs method execution  <br>                      System returns autotest, which internal or global identifier equals the identifier value set in the previous                      action                  
         * @summary Get AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal identifier (guid format) or  global identifier (integer format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestById(autoTestId: string, options?: any): AxiosPromise<AutoTestModel> {
            return localVarFp.getAutoTestById(autoTestId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search all test results related to autotest (with default limit equal 100)  <br>                      System orders the test results by CompletedOn property descending and then orders by CreatedDate property                      descending                    <br>System returns test result chronology for autotest
         * @summary Get AutoTest chronology by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestChronology(autoTestId: string, options?: any): AxiosPromise<Array<TestResultChronologyModel>> {
            return localVarFp.getAutoTestChronology(autoTestId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search for all test runs related to the autotest  <br>System returns the enumeration of test runs
         * @summary Stopped and completed TestRuns which contain AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRuns(autoTestId: string, options?: any): AxiosPromise<Array<TestRunShortModel>> {
            return localVarFp.getTestRuns(autoTestId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets getTestResultHistoryReportQuery (listed in the example)  <br>User runs method execution  <br>System search for test results using filters set by user in getTestResultHistoryReportQuery and autoTestId  <br>System returns the enumeration of test results
         * @summary History of TestResults for AutoTest by Id or GlobalId
         * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {Array<string>} [configurationIds] 
         * @param {Array<string>} [testPlanIds] 
         * @param {Array<string>} [userIds] 
         * @param {Array<string>} [outcomes] 
         * @param {boolean} [isAutomated] 
         * @param {Array<string>} [testRunIds] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemResults(autoTestId: string, from?: string, to?: string, configurationIds?: Array<string>, testPlanIds?: Array<string>, userIds?: Array<string>, outcomes?: Array<string>, isAutomated?: boolean, testRunIds?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<TestResultHistoryReportModel>> {
            return localVarFp.getWorkItemResults(autoTestId, from, to, configurationIds, testPlanIds, userIds, outcomes, isAutomated, testRunIds, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System finds all actual and not deleted WorkItems related to the found autotest  <br>System returns the enumeration of WorkItems
         * @summary Get all WorkItems Ids linked to AutoTest by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {boolean} [isWorkItemDeleted] Boolean flag which defines if search must include deleted worItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsLinkedToAutoTest(autoTestId: string, isWorkItemDeleted?: boolean, options?: any): AxiosPromise<Array<WorkItemIdModel>> {
            return localVarFp.getWorkItemsLinkedToAutoTest(autoTestId, isWorkItemDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>System finds the workitem by the workitem identifier  <br>System relates the workitem with the autotest and returns no content response
         * @summary Link AutoTest to WorkItem by Id or GlobalId
         * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
         * @param {WorkItemIdModel} [workItemIdModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAutoTestToWorkItem(autoTestId: string, workItemIdModel?: WorkItemIdModel, options?: any): AxiosPromise<void> {
            return localVarFp.linkAutoTestToWorkItem(autoTestId, workItemIdModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTest
         * @param {AutoTestPutModel} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoTest(autoTestPutModel?: AutoTestPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateAutoTest(autoTestPutModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
         * @summary Update AutoTests multiple
         * @param {Array<AutoTestPutModel>} [autoTestPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMultiple(autoTestPutModel?: Array<AutoTestPutModel>, options?: any): AxiosPromise<void> {
            return localVarFp.updateMultiple(autoTestPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutoTestsApi - object-oriented interface
 * @export
 * @class AutoTestsApi
 * @extends {BaseAPI}
 */
export class AutoTestsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
     * @summary Create AutoTest
     * @param {AutoTestPostModel} [autoTestPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public createAutoTest(autoTestPostModel?: AutoTestPostModel, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).createAutoTest(autoTestPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest parameters (listed in the example) and runs method execution  <br>System creates autotest  <br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest  <br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest  <br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest  <br>[Optional] If label enumeration is set, system creates labels and relates them to autotest  <br>[Optional] If link enumeration is set, system creates links and relates them to autotest  <br>System returns autotest model (example listed in response parameters)
     * @summary Create AutoTests multiple
     * @param {Array<AutoTestPostModel>} [autoTestPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public createMultiple(autoTestPostModel?: Array<AutoTestPostModel>, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).createMultiple(autoTestPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System deletes autotest and returns no content response
     * @summary Delete AutoTest by Id or GlobalId
     * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier \&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public deleteAutoTest(autoTestId: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).deleteAutoTest(autoTestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>[Optional] User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>                      [Optional] if workitem id is set by User, System finds the workitem by the workitem identifier and unlinks it                      from autotest.                    <br>[Optional] Otherwise, if workitem id is not specified, System unlinks all workitems linked to autotest.  <br>System returns no content response
     * @summary Delete AutoTest link from WorkItem by Id or GlobalId  (if workItemId is not specified, then remove all links WorkItems to AutoTest)
     * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
     * @param {string} [workItemId] workItem internal (guid format) or global  (integer format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public deleteAutoTestLinkFromWorkItem(autoTestId: string, workItemId?: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).deleteAutoTestLinkFromWorkItem(autoTestId, workItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>[Optional] User sets search parameters (listed in request parameters) and runs method execution  <br>System returns all autotests, matching search criteria
     * @summary Get all AutoTests (if parameters are specified, then it\'s filtered by them.)
     * @param {string} [projectId] Project internal identifier
     * @param {string} [externalId] Autotest external identifier
     * @param {number} [globalId] Autotest global identifier
     * @param {string} [namespace] Name of abstract storage where autotest is located
     * @param {boolean} [isNamespaceNull] Boolean flag which defines if search must include autotests with null  value Namespace attribute
     * @param {string} [classname] Name of the class where autotest is located
     * @param {boolean} [isClassnameNull] Boolean flag which defines if search must include autotests with null  value Classname attribute
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted autotests
     * @param {Array<string>} [labels] List of autotests labels to filter by
     * @param {number} [stabilityMinimal] Minimal stability value to filter by
     * @param {number} [stabilityMaximal] Maximal stability value to filter by
     * @param {boolean} [isFlaky] [Optional] If flaky is set
     * @param {boolean} [includeSteps] Boolean flag which defines if setup, steps and teardown fields must be included
     * @param {boolean} [includeLabels] Boolean flag which defines if labels field must be included
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getAllAutoTests(projectId?: string, externalId?: string, globalId?: number, namespace?: string, isNamespaceNull?: boolean, classname?: string, isClassnameNull?: boolean, isDeleted?: boolean, labels?: Array<string>, stabilityMinimal?: number, stabilityMaximal?: number, isFlaky?: boolean, includeSteps?: boolean, includeLabels?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getAllAutoTests(projectId, externalId, globalId, namespace, isNamespaceNull, classname, isClassnameNull, isDeleted, labels, stabilityMinimal, stabilityMaximal, isFlaky, includeSteps, includeLabels, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System calculates pass average duration and fail average duration of autotest from all related test results  <br>System returns pass average duration and fail average duration for autotest
     * @summary Get AutoTest average duration by Id or GlobalId
     * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getAutoTestAverageDuration(autoTestId: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getAutoTestAverageDuration(autoTestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal or global identifier and runs method execution  <br>                      System returns autotest, which internal or global identifier equals the identifier value set in the previous                      action                  
     * @summary Get AutoTest by Id or GlobalId
     * @param {string} autoTestId Autotest internal identifier (guid format) or  global identifier (integer format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getAutoTestById(autoTestId: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getAutoTestById(autoTestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search all test results related to autotest (with default limit equal 100)  <br>                      System orders the test results by CompletedOn property descending and then orders by CreatedDate property                      descending                    <br>System returns test result chronology for autotest
     * @summary Get AutoTest chronology by Id or GlobalId
     * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getAutoTestChronology(autoTestId: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getAutoTestChronology(autoTestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search for all test runs related to the autotest  <br>System returns the enumeration of test runs
     * @summary Stopped and completed TestRuns which contain AutoTest by Id or GlobalId
     * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getTestRuns(autoTestId: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getTestRuns(autoTestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets getTestResultHistoryReportQuery (listed in the example)  <br>User runs method execution  <br>System search for test results using filters set by user in getTestResultHistoryReportQuery and autoTestId  <br>System returns the enumeration of test results
     * @summary History of TestResults for AutoTest by Id or GlobalId
     * @param {string} autoTestId autotest internal (guid format) or global  (integer format) identifier
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {Array<string>} [configurationIds] 
     * @param {Array<string>} [testPlanIds] 
     * @param {Array<string>} [userIds] 
     * @param {Array<string>} [outcomes] 
     * @param {boolean} [isAutomated] 
     * @param {Array<string>} [testRunIds] 
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getWorkItemResults(autoTestId: string, from?: string, to?: string, configurationIds?: Array<string>, testPlanIds?: Array<string>, userIds?: Array<string>, outcomes?: Array<string>, isAutomated?: boolean, testRunIds?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getWorkItemResults(autoTestId, from, to, configurationIds, testPlanIds, userIds, outcomes, isAutomated, testRunIds, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution  <br>System finds the autotest by the identifier  <br>System finds all actual and not deleted WorkItems related to the found autotest  <br>System returns the enumeration of WorkItems
     * @summary Get all WorkItems Ids linked to AutoTest by Id or GlobalId
     * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
     * @param {boolean} [isWorkItemDeleted] Boolean flag which defines if search must include deleted worItems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public getWorkItemsLinkedToAutoTest(autoTestId: string, isWorkItemDeleted?: boolean, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).getWorkItemsLinkedToAutoTest(autoTestId, isWorkItemDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest internal (guid format) or global (integer format) identifier  <br>User sets workitem internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System finds the autotest by the autotest identifier  <br>System finds the workitem by the workitem identifier  <br>System relates the workitem with the autotest and returns no content response
     * @summary Link AutoTest to WorkItem by Id or GlobalId
     * @param {string} autoTestId Autotest internal (guid format) or global  (integer format) identifier
     * @param {WorkItemIdModel} [workItemIdModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public linkAutoTestToWorkItem(autoTestId: string, workItemIdModel?: WorkItemIdModel, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).linkAutoTestToWorkItem(autoTestId, workItemIdModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
     * @summary Update AutoTest
     * @param {AutoTestPutModel} [autoTestPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public updateAutoTest(autoTestPutModel?: AutoTestPutModel, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).updateAutoTest(autoTestPutModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets autotest updated parameters values (listed in the example) and runs method execution  <br>System finds the autotest by the identifier  <br>System updates autotest parameters   <br>                      [Optional] If steps enumeration is set, system creates step items, relates them to autotest                      and deletes relations with current steps( if exist)                    <br>                      [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest                      and deletes relations with current Setup items (if exist)                    <br>                      [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest                      and deletes relations with current teardown items (if exist)                    <br>                      [Optional] If label enumeration is set, system creates labels and relates them to autotest                      and deletes relations with current Labels (if exist)                    <br>                      [Optional] If link enumeration is set, system creates links and relates them to autotest                      and deletes relations with current Links (if exist)                    <br>System updates autotest and returns no content response
     * @summary Update AutoTests multiple
     * @param {Array<AutoTestPutModel>} [autoTestPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoTestsApi
     */
    public updateMultiple(autoTestPutModel?: Array<AutoTestPutModel>, options?: AxiosRequestConfig) {
        return AutoTestsApiFp(this.configuration).updateMultiple(autoTestPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationsApi - axios parameter creator
 * @export
 */
export const ConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets configuration model (listed in the request example)  <br>User runs method execution  <br>System creates configuration  <br>System returns created configuration (listed in the response example)
         * @summary Create Configuration
         * @param {ConfigurationPostModel} [configurationPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfiguration: async (configurationPostModel?: ConfigurationPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets configuration internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search configuration using the identifier  <br>System returns configuration
         * @summary Get Configuration by Id or GlobalId
         * @param {string} configurationId Configuration internal (guid format) or global (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationById: async (configurationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'configurationId' is not null or undefined
            assertParamExists('getConfigurationById', 'configurationId', configurationId)
            const localVarPath = `/api/v2/configurations/{configurationId}`
                .replace(`{${"configurationId"}}`, encodeURIComponent(String(configurationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets configuration updated properties(listed in the request example)  <br>User runs method execution  <br>System updated configuration using updated properties  <br>System returns no content response
         * @summary Update Configuration
         * @param {ConfigurationPutModel} [configurationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration: async (configurationPutModel?: ConfigurationPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configurationPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationsApi - functional programming interface
 * @export
 */
export const ConfigurationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets configuration model (listed in the request example)  <br>User runs method execution  <br>System creates configuration  <br>System returns created configuration (listed in the response example)
         * @summary Create Configuration
         * @param {ConfigurationPostModel} [configurationPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConfiguration(configurationPostModel?: ConfigurationPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConfiguration(configurationPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets configuration internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search configuration using the identifier  <br>System returns configuration
         * @summary Get Configuration by Id or GlobalId
         * @param {string} configurationId Configuration internal (guid format) or global (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationById(configurationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurationById(configurationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets configuration updated properties(listed in the request example)  <br>User runs method execution  <br>System updated configuration using updated properties  <br>System returns no content response
         * @summary Update Configuration
         * @param {ConfigurationPutModel} [configurationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfiguration(configurationPutModel?: ConfigurationPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfiguration(configurationPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigurationsApi - factory interface
 * @export
 */
export const ConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets configuration model (listed in the request example)  <br>User runs method execution  <br>System creates configuration  <br>System returns created configuration (listed in the response example)
         * @summary Create Configuration
         * @param {ConfigurationPostModel} [configurationPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfiguration(configurationPostModel?: ConfigurationPostModel, options?: any): AxiosPromise<ConfigurationModel> {
            return localVarFp.createConfiguration(configurationPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets configuration internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search configuration using the identifier  <br>System returns configuration
         * @summary Get Configuration by Id or GlobalId
         * @param {string} configurationId Configuration internal (guid format) or global (integer format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationById(configurationId: string, options?: any): AxiosPromise<ConfigurationModel> {
            return localVarFp.getConfigurationById(configurationId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets configuration updated properties(listed in the request example)  <br>User runs method execution  <br>System updated configuration using updated properties  <br>System returns no content response
         * @summary Update Configuration
         * @param {ConfigurationPutModel} [configurationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration(configurationPutModel?: ConfigurationPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateConfiguration(configurationPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationsApi - object-oriented interface
 * @export
 * @class ConfigurationsApi
 * @extends {BaseAPI}
 */
export class ConfigurationsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets configuration model (listed in the request example)  <br>User runs method execution  <br>System creates configuration  <br>System returns created configuration (listed in the response example)
     * @summary Create Configuration
     * @param {ConfigurationPostModel} [configurationPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public createConfiguration(configurationPostModel?: ConfigurationPostModel, options?: AxiosRequestConfig) {
        return ConfigurationsApiFp(this.configuration).createConfiguration(configurationPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets configuration internal (guid format) or global (integer format) identifier  <br>User runs method execution  <br>System search configuration using the identifier  <br>System returns configuration
     * @summary Get Configuration by Id or GlobalId
     * @param {string} configurationId Configuration internal (guid format) or global (integer format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public getConfigurationById(configurationId: string, options?: AxiosRequestConfig) {
        return ConfigurationsApiFp(this.configuration).getConfigurationById(configurationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets configuration updated properties(listed in the request example)  <br>User runs method execution  <br>System updated configuration using updated properties  <br>System returns no content response
     * @summary Update Configuration
     * @param {ConfigurationPutModel} [configurationPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public updateConfiguration(configurationPutModel?: ConfigurationPutModel, options?: AxiosRequestConfig) {
        return ConfigurationsApiFp(this.configuration).updateConfiguration(configurationPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParametersApi - axios parameter creator
 * @export
 */
export const ParametersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets parameter model (listed in the request example)  <br>User runs method execution  <br>System creates parameter  <br>System returns parameter model
         * @summary Create parameter
         * @param {ParameterPostModel} [parameterPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameter: async (parameterPostModel?: ParameterPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameterPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes parameter and all it\'s values
         * @summary Delete parameter by name
         * @param {string} name Name of the parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByName: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteByName', 'name', name)
            const localVarPath = `/api/v2/parameters/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>System search and delete parameter  <br>System returns deleted parameter
         * @summary Delete parameter by id
         * @param {string} parameterId Parameter internal(guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParameter: async (parameterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parameterId' is not null or undefined
            assertParamExists('deleteParameter', 'parameterId', parameterId)
            const localVarPath = `/api/v2/parameters/{parameterId}`
                .replace(`{${"parameterId"}}`, encodeURIComponent(String(parameterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted parameters  <br>[Optional] If User sets isDeleted field value as false, System search all parameters which are not deleted  <br>If User did not set isDeleted field value, System search all parameters  <br>System returns array of all found parameters(listed in response model)
         * @summary Get all parameters (if isDeleted is true, return deleted parameters)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted parameters
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllParameters: async (isDeleted?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>User runs method execution  <br>System search parameter using the identifier  <br>System returns parameter
         * @summary Get parameter by id
         * @param {string} parameterId Parameter internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterById: async (parameterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parameterId' is not null or undefined
            assertParamExists('getParameterById', 'parameterId', parameterId)
            const localVarPath = `/api/v2/parameters/{parameterId}`
                .replace(`{${"parameterId"}}`, encodeURIComponent(String(parameterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets parameter name (string format)  <br>System search and delete parameter  <br>System returns no content response
         * @summary Delete parameters by name
         * @param {string} [name] Parameter name(string format)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteDeleteByName: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/parameters/deleteByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets parameter updated properties(listed in the request example)  <br>User runs method execution  <br>System updated parameter using updated properties  <br>System returns no content response
         * @summary Update parameter
         * @param {ParameterPutModel} [parameterPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameter: async (parameterPutModel?: ParameterPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameterPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParametersApi - functional programming interface
 * @export
 */
export const ParametersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParametersApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets parameter model (listed in the request example)  <br>User runs method execution  <br>System creates parameter  <br>System returns parameter model
         * @summary Create parameter
         * @param {ParameterPostModel} [parameterPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParameter(parameterPostModel?: ParameterPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParameter(parameterPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes parameter and all it\'s values
         * @summary Delete parameter by name
         * @param {string} name Name of the parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteByName(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteByName(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>System search and delete parameter  <br>System returns deleted parameter
         * @summary Delete parameter by id
         * @param {string} parameterId Parameter internal(guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParameter(parameterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParameter(parameterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted parameters  <br>[Optional] If User sets isDeleted field value as false, System search all parameters which are not deleted  <br>If User did not set isDeleted field value, System search all parameters  <br>System returns array of all found parameters(listed in response model)
         * @summary Get all parameters (if isDeleted is true, return deleted parameters)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted parameters
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllParameters(isDeleted?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParameterModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllParameters(isDeleted, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>User runs method execution  <br>System search parameter using the identifier  <br>System returns parameter
         * @summary Get parameter by id
         * @param {string} parameterId Parameter internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParameterById(parameterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParameterById(parameterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets parameter name (string format)  <br>System search and delete parameter  <br>System returns no content response
         * @summary Delete parameters by name
         * @param {string} [name] Parameter name(string format)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async obsoleteDeleteByName(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obsoleteDeleteByName(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets parameter updated properties(listed in the request example)  <br>User runs method execution  <br>System updated parameter using updated properties  <br>System returns no content response
         * @summary Update parameter
         * @param {ParameterPutModel} [parameterPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameter(parameterPutModel?: ParameterPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameter(parameterPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParametersApi - factory interface
 * @export
 */
export const ParametersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParametersApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets parameter model (listed in the request example)  <br>User runs method execution  <br>System creates parameter  <br>System returns parameter model
         * @summary Create parameter
         * @param {ParameterPostModel} [parameterPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameter(parameterPostModel?: ParameterPostModel, options?: any): AxiosPromise<ParameterModel> {
            return localVarFp.createParameter(parameterPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes parameter and all it\'s values
         * @summary Delete parameter by name
         * @param {string} name Name of the parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByName(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>System search and delete parameter  <br>System returns deleted parameter
         * @summary Delete parameter by id
         * @param {string} parameterId Parameter internal(guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParameter(parameterId: string, options?: any): AxiosPromise<ParameterModel> {
            return localVarFp.deleteParameter(parameterId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted parameters  <br>[Optional] If User sets isDeleted field value as false, System search all parameters which are not deleted  <br>If User did not set isDeleted field value, System search all parameters  <br>System returns array of all found parameters(listed in response model)
         * @summary Get all parameters (if isDeleted is true, return deleted parameters)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted parameters
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllParameters(isDeleted?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<ParameterModel>> {
            return localVarFp.getAllParameters(isDeleted, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>User runs method execution  <br>System search parameter using the identifier  <br>System returns parameter
         * @summary Get parameter by id
         * @param {string} parameterId Parameter internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterById(parameterId: string, options?: any): AxiosPromise<ParameterModel> {
            return localVarFp.getParameterById(parameterId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets parameter name (string format)  <br>System search and delete parameter  <br>System returns no content response
         * @summary Delete parameters by name
         * @param {string} [name] Parameter name(string format)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteDeleteByName(name?: string, options?: any): AxiosPromise<void> {
            return localVarFp.obsoleteDeleteByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets parameter updated properties(listed in the request example)  <br>User runs method execution  <br>System updated parameter using updated properties  <br>System returns no content response
         * @summary Update parameter
         * @param {ParameterPutModel} [parameterPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameter(parameterPutModel?: ParameterPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateParameter(parameterPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParametersApi - object-oriented interface
 * @export
 * @class ParametersApi
 * @extends {BaseAPI}
 */
export class ParametersApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets parameter model (listed in the request example)  <br>User runs method execution  <br>System creates parameter  <br>System returns parameter model
     * @summary Create parameter
     * @param {ParameterPostModel} [parameterPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public createParameter(parameterPostModel?: ParameterPostModel, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).createParameter(parameterPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes parameter and all it\'s values
     * @summary Delete parameter by name
     * @param {string} name Name of the parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public deleteByName(name: string, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).deleteByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>System search and delete parameter  <br>System returns deleted parameter
     * @summary Delete parameter by id
     * @param {string} parameterId Parameter internal(guid format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public deleteParameter(parameterId: string, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).deleteParameter(parameterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted parameters  <br>[Optional] If User sets isDeleted field value as false, System search all parameters which are not deleted  <br>If User did not set isDeleted field value, System search all parameters  <br>System returns array of all found parameters(listed in response model)
     * @summary Get all parameters (if isDeleted is true, return deleted parameters)
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted parameters
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public getAllParameters(isDeleted?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).getAllParameters(isDeleted, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets parameter internal (guid format) identifier  <br>User runs method execution  <br>System search parameter using the identifier  <br>System returns parameter
     * @summary Get parameter by id
     * @param {string} parameterId Parameter internal (guid format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public getParameterById(parameterId: string, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).getParameterById(parameterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets parameter name (string format)  <br>System search and delete parameter  <br>System returns no content response
     * @summary Delete parameters by name
     * @param {string} [name] Parameter name(string format)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public obsoleteDeleteByName(name?: string, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).obsoleteDeleteByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets parameter updated properties(listed in the request example)  <br>User runs method execution  <br>System updated parameter using updated properties  <br>System returns no content response
     * @summary Update parameter
     * @param {ParameterPutModel} [parameterPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public updateParameter(parameterPutModel?: ParameterPutModel, options?: AxiosRequestConfig) {
        return ParametersApiFp(this.configuration).updateParameter(parameterPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections and                      workitems                  
         * @summary Export Project with tests, sections and configurations in json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportQueryModel} [projectExportQueryModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (projectId: string, includeAttachments?: boolean, projectExportQueryModel?: ProjectExportQueryModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('_export', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/export`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeAttachments !== undefined) {
                localVarQueryParameter['includeAttachments'] = includeAttachments;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectExportQueryModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System creates project  <br>System returns no content response
         * @summary Import Project from json file  Project can be imported only once (this method or ImportToExistingProject)  Next import will sync content in previously imported project.
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import: async (apiVersion?: string, includeAttachments?: boolean, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (apiVersion !== undefined) {
                localVarQueryParameter['apiVersion'] = apiVersion;
            }

            if (includeAttachments !== undefined) {
                localVarQueryParameter['includeAttachments'] = includeAttachments;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attributes identifiers  <br>User runs method execution  <br>System updates project and add attributes to project for test plans  <br>System returns no content response
         * @summary Add attributes to project for test plans
         * @param {string} projectId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomAttributeTestPlanProjectRelations: async (projectId: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomAttributeTestPlanProjectRelations', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/testPlans/attributes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System creates project  <br>System returns project model (example listed in response parameters)
         * @summary Create Project
         * @param {ProjectPostModel} [projectPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectPostModel?: ProjectPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets attribute parameters (listed in request example) and runs method execution  <br>System search project  <br>System creates attribute and relates it to the project  <br>System returns project attribute properties (example listed in response parameters)
         * @summary Create Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributePostModel} [customAttributePostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectsAttribute: async (projectId: string, customAttributePostModel?: CustomAttributePostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectsAttribute', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/attributes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customAttributePostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute identifier  <br>User runs method execution  <br>System updates project and delete attribute from project for test plans  <br>System returns no content response
         * @summary Delete attribute from project for test plans
         * @param {string} projectId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomAttributeTestPlanProjectRelations: async (projectId: string, attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCustomAttributeTestPlanProjectRelations', 'projectId', projectId)
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteCustomAttributeTestPlanProjectRelations', 'attributeId', attributeId)
            const localVarPath = `/api/v2/projects/{projectId}/testPlans/attribute/{attributeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and delete project  <br>System returns no content response
         * @summary Delete Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier   <br>User runs method execution  <br>System delete all autotests from project  <br>System returns no content response
         * @summary Delete all AutoTests from Project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectAutoTests: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectAutoTests', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/autoTests`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project identifier and runs method execution  <br>User sets attribute identifier  <br>User runs method execution  <br>System search project  <br>System search and delete attribute  <br>System returns no content response
         * @summary Delete Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectsAttribute: async (projectId: string, attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectsAttribute', 'projectId', projectId)
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteProjectsAttribute', 'attributeId', attributeId)
            const localVarPath = `/api/v2/projects/{projectId}/attributes/{attributeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections, workitems,                      test plans, test suites, test points and configurations                  
         * @summary Export Project with tests, sections, configurations, testPlans, testSuites and testPoints as json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportWithTestPlansPostModel} [projectExportWithTestPlansPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWithTestPlansAndConfigurations: async (projectId: string, includeAttachments?: boolean, projectExportWithTestPlansPostModel?: ProjectExportWithTestPlansPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportWithTestPlansAndConfigurations', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/export-by-testPlans`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeAttachments !== undefined) {
                localVarQueryParameter['includeAttachments'] = includeAttachments;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectExportWithTestPlansPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted projects  <br>[Optional] If User sets isDeleted field value as false, System search all projects which are not deleted  <br>If User did not set isDeleted field value, System search all projects  <br>System returns array of all found projects(listed in response model)
         * @summary Get all Projects (if isDeleted is true, return deleted Projects)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted projects
         * @param {string} [projectName] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjects: async (isDeleted?: boolean, projectName?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (projectName !== undefined) {
                localVarQueryParameter['projectName'] = projectName;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User sets project attribute identifier  <br>User runs method execution  <br>System search project  <br>System search project attribute   <br>System returns project attribute (listed in response model)
         * @summary Get Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeByProjectId: async (projectId: string, attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAttributeByProjectId', 'projectId', projectId)
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getAttributeByProjectId', 'attributeId', attributeId)
            const localVarPath = `/api/v2/projects/{projectId}/attributes/{attributeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted attributes related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all attributes related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all attributes related to project  <br>System returns array of found attributes (listed in response model)
         * @summary Get Projects Attributes by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesByProjectId: async (projectId: string, isDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAttributesByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/attributes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all autotest related to the project  <br>System returns array of autotest with namespaces and classnames (listed in response)
         * @summary Get AutoTests Namespaces for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestsNamespaces: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAutoTestsNamespaces', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/autoTestsNamespaces`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all configurations related to project  <br>System returns array of found configurations (listed in response model)
         * @summary Get Configurations for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationsByProjectId: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getConfigurationsByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/configurations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User runs method execution  <br>System returns project for test plans attributes by project identifier
         * @summary Get project for test plans attributes
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomAttributeTestPlanProjectRelations: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCustomAttributeTestPlanProjectRelations', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/testPlans/attributes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System returns project (example listed in response parameters)
         * @summary Get Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectById', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all sections related to the project  <br>System returns array of sections (listed in response)
         * @summary Get Sections for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsByProjectId: async (projectId: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSectionsByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/sections`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted test plans related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all test plans related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all v related to project  <br>System returns array of found test plans (listed in response model)
         * @summary Get TestPlans for Project by Id or GlobalId (if isDeleted is true, return deleted TestPlans)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted test plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPlansByProjectId: async (projectId: string, isDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTestPlansByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/testPlans`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all test runs related to project  <br>System returns array of found test runs (listed in response model)
         * @summary Get TestRuns for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [notStarted] 
         * @param {boolean} [inProgress] 
         * @param {boolean} [stopped] 
         * @param {boolean} [completed] 
         * @param {string} [createdDateFrom] 
         * @param {string} [createdDateTo] 
         * @param {string} [testPlanId] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRunsByProjectId: async (projectId: string, notStarted?: boolean, inProgress?: boolean, stopped?: boolean, completed?: boolean, createdDateFrom?: string, createdDateTo?: string, testPlanId?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTestRunsByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/testRuns`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (notStarted !== undefined) {
                localVarQueryParameter['NotStarted'] = notStarted;
            }

            if (inProgress !== undefined) {
                localVarQueryParameter['InProgress'] = inProgress;
            }

            if (stopped !== undefined) {
                localVarQueryParameter['Stopped'] = stopped;
            }

            if (completed !== undefined) {
                localVarQueryParameter['Completed'] = completed;
            }

            if (createdDateFrom !== undefined) {
                localVarQueryParameter['CreatedDateFrom'] = (createdDateFrom as any instanceof Date) ?
                    (createdDateFrom as any).toISOString() :
                    createdDateFrom;
            }

            if (createdDateTo !== undefined) {
                localVarQueryParameter['CreatedDateTo'] = (createdDateTo as any instanceof Date) ?
                    (createdDateTo as any).toISOString() :
                    createdDateTo;
            }

            if (testPlanId !== undefined) {
                localVarQueryParameter['TestPlanId'] = testPlanId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>[Optional] If User sets isDeleted field value as true, System search all deleted workitems related to project  <br>                      [Optional] If User sets isDeleted field value as false, System search all workitems related to project which                      are not deleted                    <br>If User did not set isDeleted field value, System search all  workitems related to project  <br>System returns array of found workitems (listed in response model)
         * @summary Get WorkItems for Project by Id or GlobalId (if isDeleted is true, return deleted WorkItems)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted workitems
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsByProjectId: async (projectId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getWorkItemsByProjectId', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/workItems`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (tagNames) {
                localVarQueryParameter['tagNames'] = tagNames;
            }

            if (includeIterations !== undefined) {
                localVarQueryParameter['includeIterations'] = includeIterations;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System updates project  <br>System returns no content response
         * @summary Import to existing Project from json file.  Sections can be imported in only one target project!
         * @param {string} projectId 
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importToExistingProject: async (projectId: string, apiVersion?: string, includeAttachments?: boolean, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importToExistingProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/import`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (apiVersion !== undefined) {
                localVarQueryParameter['apiVersion'] = apiVersion;
            }

            if (includeAttachments !== undefined) {
                localVarQueryParameter['includeAttachments'] = includeAttachments;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and restores deleted project  <br>System returns no content response
         * @summary Restore Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('restoreProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/restore`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute model  <br>User runs method execution  <br>System updates project and project attribute for test plan  <br>System returns no content response
         * @summary Update project attribute for test plan
         * @param {string} projectId 
         * @param {CustomAttributeTestPlanProjectRelationPutModel} [customAttributeTestPlanProjectRelationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomAttributeTestPlanProjectRelations: async (projectId: string, customAttributeTestPlanProjectRelationPutModel?: CustomAttributeTestPlanProjectRelationPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCustomAttributeTestPlanProjectRelations', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/testPlans/attribute`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customAttributeTestPlanProjectRelationPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System returns updated project model (example listed in response parameters)
         * @summary Update Project
         * @param {ProjectPutModel} [projectPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectPutModel?: ProjectPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System updates attribute related to the project  <br>System returns no content response
         * @summary Update Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributeModel} [customAttributeModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectsAttribute: async (projectId: string, customAttributeModel?: CustomAttributeModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectsAttribute', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/attributes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customAttributeModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections and                      workitems                  
         * @summary Export Project with tests, sections and configurations in json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportQueryModel} [projectExportQueryModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(projectId: string, includeAttachments?: boolean, projectExportQueryModel?: ProjectExportQueryModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(projectId, includeAttachments, projectExportQueryModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System creates project  <br>System returns no content response
         * @summary Import Project from json file  Project can be imported only once (this method or ImportToExistingProject)  Next import will sync content in previously imported project.
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _import(apiVersion?: string, includeAttachments?: boolean, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._import(apiVersion, includeAttachments, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attributes identifiers  <br>User runs method execution  <br>System updates project and add attributes to project for test plans  <br>System returns no content response
         * @summary Add attributes to project for test plans
         * @param {string} projectId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomAttributeTestPlanProjectRelations(projectId: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomAttributeTestPlanProjectRelations(projectId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System creates project  <br>System returns project model (example listed in response parameters)
         * @summary Create Project
         * @param {ProjectPostModel} [projectPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectPostModel?: ProjectPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets attribute parameters (listed in request example) and runs method execution  <br>System search project  <br>System creates attribute and relates it to the project  <br>System returns project attribute properties (example listed in response parameters)
         * @summary Create Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributePostModel} [customAttributePostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectsAttribute(projectId: string, customAttributePostModel?: CustomAttributePostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomAttributeModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectsAttribute(projectId, customAttributePostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute identifier  <br>User runs method execution  <br>System updates project and delete attribute from project for test plans  <br>System returns no content response
         * @summary Delete attribute from project for test plans
         * @param {string} projectId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomAttributeTestPlanProjectRelations(projectId: string, attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomAttributeTestPlanProjectRelations(projectId, attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and delete project  <br>System returns no content response
         * @summary Delete Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier   <br>User runs method execution  <br>System delete all autotests from project  <br>System returns no content response
         * @summary Delete all AutoTests from Project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectAutoTests(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectAutoTests(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project identifier and runs method execution  <br>User sets attribute identifier  <br>User runs method execution  <br>System search project  <br>System search and delete attribute  <br>System returns no content response
         * @summary Delete Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectsAttribute(projectId: string, attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectsAttribute(projectId, attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections, workitems,                      test plans, test suites, test points and configurations                  
         * @summary Export Project with tests, sections, configurations, testPlans, testSuites and testPoints as json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportWithTestPlansPostModel} [projectExportWithTestPlansPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportWithTestPlansAndConfigurations(projectId: string, includeAttachments?: boolean, projectExportWithTestPlansPostModel?: ProjectExportWithTestPlansPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportWithTestPlansAndConfigurations(projectId, includeAttachments, projectExportWithTestPlansPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted projects  <br>[Optional] If User sets isDeleted field value as false, System search all projects which are not deleted  <br>If User did not set isDeleted field value, System search all projects  <br>System returns array of all found projects(listed in response model)
         * @summary Get all Projects (if isDeleted is true, return deleted Projects)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted projects
         * @param {string} [projectName] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProjects(isDeleted?: boolean, projectName?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProjects(isDeleted, projectName, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User sets project attribute identifier  <br>User runs method execution  <br>System search project  <br>System search project attribute   <br>System returns project attribute (listed in response model)
         * @summary Get Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributeByProjectId(projectId: string, attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomAttributeModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttributeByProjectId(projectId, attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted attributes related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all attributes related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all attributes related to project  <br>System returns array of found attributes (listed in response model)
         * @summary Get Projects Attributes by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributesByProjectId(projectId: string, isDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomAttributeModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttributesByProjectId(projectId, isDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all autotest related to the project  <br>System returns array of autotest with namespaces and classnames (listed in response)
         * @summary Get AutoTests Namespaces for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoTestsNamespaces(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoTestNamespaceModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoTestsNamespaces(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all configurations related to project  <br>System returns array of found configurations (listed in response model)
         * @summary Get Configurations for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationsByProjectId(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurationsByProjectId(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User runs method execution  <br>System returns project for test plans attributes by project identifier
         * @summary Get project for test plans attributes
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomAttributeTestPlanProjectRelations(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomAttributeModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomAttributeTestPlanProjectRelations(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System returns project (example listed in response parameters)
         * @summary Get Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectById(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectById(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all sections related to the project  <br>System returns array of sections (listed in response)
         * @summary Get Sections for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionsByProjectId(projectId: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SectionModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionsByProjectId(projectId, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted test plans related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all test plans related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all v related to project  <br>System returns array of found test plans (listed in response model)
         * @summary Get TestPlans for Project by Id or GlobalId (if isDeleted is true, return deleted TestPlans)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted test plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestPlansByProjectId(projectId: string, isDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestPlanModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestPlansByProjectId(projectId, isDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all test runs related to project  <br>System returns array of found test runs (listed in response model)
         * @summary Get TestRuns for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [notStarted] 
         * @param {boolean} [inProgress] 
         * @param {boolean} [stopped] 
         * @param {boolean} [completed] 
         * @param {string} [createdDateFrom] 
         * @param {string} [createdDateTo] 
         * @param {string} [testPlanId] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRunsByProjectId(projectId: string, notStarted?: boolean, inProgress?: boolean, stopped?: boolean, completed?: boolean, createdDateFrom?: string, createdDateTo?: string, testPlanId?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestRunV2GetModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRunsByProjectId(projectId, notStarted, inProgress, stopped, completed, createdDateFrom, createdDateTo, testPlanId, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>[Optional] If User sets isDeleted field value as true, System search all deleted workitems related to project  <br>                      [Optional] If User sets isDeleted field value as false, System search all workitems related to project which                      are not deleted                    <br>If User did not set isDeleted field value, System search all  workitems related to project  <br>System returns array of found workitems (listed in response model)
         * @summary Get WorkItems for Project by Id or GlobalId (if isDeleted is true, return deleted WorkItems)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted workitems
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsByProjectId(projectId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsByProjectId(projectId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System updates project  <br>System returns no content response
         * @summary Import to existing Project from json file.  Sections can be imported in only one target project!
         * @param {string} projectId 
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importToExistingProject(projectId: string, apiVersion?: string, includeAttachments?: boolean, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importToExistingProject(projectId, apiVersion, includeAttachments, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and restores deleted project  <br>System returns no content response
         * @summary Restore Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute model  <br>User runs method execution  <br>System updates project and project attribute for test plan  <br>System returns no content response
         * @summary Update project attribute for test plan
         * @param {string} projectId 
         * @param {CustomAttributeTestPlanProjectRelationPutModel} [customAttributeTestPlanProjectRelationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomAttributeTestPlanProjectRelations(projectId: string, customAttributeTestPlanProjectRelationPutModel?: CustomAttributeTestPlanProjectRelationPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomAttributeTestPlanProjectRelations(projectId, customAttributeTestPlanProjectRelationPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System returns updated project model (example listed in response parameters)
         * @summary Update Project
         * @param {ProjectPutModel} [projectPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectPutModel?: ProjectPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System updates attribute related to the project  <br>System returns no content response
         * @summary Update Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributeModel} [customAttributeModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectsAttribute(projectId: string, customAttributeModel?: CustomAttributeModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectsAttribute(projectId, customAttributeModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections and                      workitems                  
         * @summary Export Project with tests, sections and configurations in json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportQueryModel} [projectExportQueryModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(projectId: string, includeAttachments?: boolean, projectExportQueryModel?: ProjectExportQueryModel, options?: any): AxiosPromise<File> {
            return localVarFp._export(projectId, includeAttachments, projectExportQueryModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System creates project  <br>System returns no content response
         * @summary Import Project from json file  Project can be imported only once (this method or ImportToExistingProject)  Next import will sync content in previously imported project.
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import(apiVersion?: string, includeAttachments?: boolean, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp._import(apiVersion, includeAttachments, file, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attributes identifiers  <br>User runs method execution  <br>System updates project and add attributes to project for test plans  <br>System returns no content response
         * @summary Add attributes to project for test plans
         * @param {string} projectId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomAttributeTestPlanProjectRelations(projectId: string, requestBody?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.createCustomAttributeTestPlanProjectRelations(projectId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System creates project  <br>System returns project model (example listed in response parameters)
         * @summary Create Project
         * @param {ProjectPostModel} [projectPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectPostModel?: ProjectPostModel, options?: any): AxiosPromise<ProjectModel> {
            return localVarFp.createProject(projectPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets attribute parameters (listed in request example) and runs method execution  <br>System search project  <br>System creates attribute and relates it to the project  <br>System returns project attribute properties (example listed in response parameters)
         * @summary Create Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributePostModel} [customAttributePostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectsAttribute(projectId: string, customAttributePostModel?: CustomAttributePostModel, options?: any): AxiosPromise<CustomAttributeModel> {
            return localVarFp.createProjectsAttribute(projectId, customAttributePostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute identifier  <br>User runs method execution  <br>System updates project and delete attribute from project for test plans  <br>System returns no content response
         * @summary Delete attribute from project for test plans
         * @param {string} projectId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomAttributeTestPlanProjectRelations(projectId: string, attributeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomAttributeTestPlanProjectRelations(projectId, attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and delete project  <br>System returns no content response
         * @summary Delete Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier   <br>User runs method execution  <br>System delete all autotests from project  <br>System returns no content response
         * @summary Delete all AutoTests from Project
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectAutoTests(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectAutoTests(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project identifier and runs method execution  <br>User sets attribute identifier  <br>User runs method execution  <br>System search project  <br>System search and delete attribute  <br>System returns no content response
         * @summary Delete Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectsAttribute(projectId: string, attributeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectsAttribute(projectId, attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections, workitems,                      test plans, test suites, test points and configurations                  
         * @summary Export Project with tests, sections, configurations, testPlans, testSuites and testPoints as json file
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [includeAttachments] 
         * @param {ProjectExportWithTestPlansPostModel} [projectExportWithTestPlansPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWithTestPlansAndConfigurations(projectId: string, includeAttachments?: boolean, projectExportWithTestPlansPostModel?: ProjectExportWithTestPlansPostModel, options?: any): AxiosPromise<File> {
            return localVarFp.exportWithTestPlansAndConfigurations(projectId, includeAttachments, projectExportWithTestPlansPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted projects  <br>[Optional] If User sets isDeleted field value as false, System search all projects which are not deleted  <br>If User did not set isDeleted field value, System search all projects  <br>System returns array of all found projects(listed in response model)
         * @summary Get all Projects (if isDeleted is true, return deleted Projects)
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted projects
         * @param {string} [projectName] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjects(isDeleted?: boolean, projectName?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<ProjectModel>> {
            return localVarFp.getAllProjects(isDeleted, projectName, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User sets project attribute identifier  <br>User runs method execution  <br>System search project  <br>System search project attribute   <br>System returns project attribute (listed in response model)
         * @summary Get Projects Attribute by Id
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {string} attributeId Project attribute internal(guid format)  identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeByProjectId(projectId: string, attributeId: string, options?: any): AxiosPromise<CustomAttributeModel> {
            return localVarFp.getAttributeByProjectId(projectId, attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted attributes related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all attributes related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all attributes related to project  <br>System returns array of found attributes (listed in response model)
         * @summary Get Projects Attributes by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesByProjectId(projectId: string, isDeleted?: boolean, options?: any): AxiosPromise<Array<CustomAttributeModel>> {
            return localVarFp.getAttributesByProjectId(projectId, isDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all autotest related to the project  <br>System returns array of autotest with namespaces and classnames (listed in response)
         * @summary Get AutoTests Namespaces for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestsNamespaces(projectId: string, options?: any): AxiosPromise<Array<AutoTestNamespaceModel>> {
            return localVarFp.getAutoTestsNamespaces(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all configurations related to project  <br>System returns array of found configurations (listed in response model)
         * @summary Get Configurations for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationsByProjectId(projectId: string, options?: any): AxiosPromise<Array<ConfigurationModel>> {
            return localVarFp.getConfigurationsByProjectId(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User runs method execution  <br>System returns project for test plans attributes by project identifier
         * @summary Get project for test plans attributes
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomAttributeTestPlanProjectRelations(projectId: string, options?: any): AxiosPromise<Array<CustomAttributeModel>> {
            return localVarFp.getCustomAttributeTestPlanProjectRelations(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System returns project (example listed in response parameters)
         * @summary Get Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById(projectId: string, options?: any): AxiosPromise<ProjectModel> {
            return localVarFp.getProjectById(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all sections related to the project  <br>System returns array of sections (listed in response)
         * @summary Get Sections for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {} [UNKNOWN_PARAMETER_NAME] Amount of items to be skipped (offset)
         * @param {} [UNKNOWN_PARAMETER_NAME2] Amount of items to be taken (limit)
         * @param {} [UNKNOWN_PARAMETER_NAME3] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {} [UNKNOWN_PARAMETER_NAME4] Property name for searching
         * @param {} [UNKNOWN_PARAMETER_NAME5] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionsByProjectId(projectId: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<SectionModel>> {
            return localVarFp.getSectionsByProjectId(projectId, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted test plans related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all test plans related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all v related to project  <br>System returns array of found test plans (listed in response model)
         * @summary Get TestPlans for Project by Id or GlobalId (if isDeleted is true, return deleted TestPlans)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted test plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPlansByProjectId(projectId: string, isDeleted?: boolean, options?: any): AxiosPromise<Array<TestPlanModel>> {
            return localVarFp.getTestPlansByProjectId(projectId, isDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all test runs related to project  <br>System returns array of found test runs (listed in response model)
         * @summary Get TestRuns for Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [notStarted] 
         * @param {boolean} [inProgress] 
         * @param {boolean} [stopped] 
         * @param {boolean} [completed] 
         * @param {string} [createdDateFrom] 
         * @param {string} [createdDateTo] 
         * @param {string} [testPlanId] 
         * @param {} [UNKNOWN_PARAMETER_NAME] Amount of items to be skipped (offset)
         * @param {} [UNKNOWN_PARAMETER_NAME2] Amount of items to be taken (limit)
         * @param {} [UNKNOWN_PARAMETER_NAME3] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {} [UNKNOWN_PARAMETER_NAME4] Property name for searching
         * @param {} [UNKNOWN_PARAMETER_NAME5] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRunsByProjectId(projectId: string, notStarted?: boolean, inProgress?: boolean, stopped?: boolean, completed?: boolean, createdDateFrom?: string, createdDateTo?: string, testPlanId?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<TestRunV2GetModel>> {
            return localVarFp.getTestRunsByProjectId(projectId, notStarted, inProgress, stopped, completed, createdDateFrom, createdDateTo, testPlanId, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>[Optional] If User sets isDeleted field value as true, System search all deleted workitems related to project  <br>                      [Optional] If User sets isDeleted field value as false, System search all workitems related to project which                      are not deleted                    <br>If User did not set isDeleted field value, System search all  workitems related to project  <br>System returns array of found workitems (listed in response model)
         * @summary Get WorkItems for Project by Id or GlobalId (if isDeleted is true, return deleted WorkItems)
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted workitems
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {} [UNKNOWN_PARAMETER_NAME] Amount of items to be skipped (offset)
         * @param {} [UNKNOWN_PARAMETER_NAME2] Amount of items to be taken (limit)
         * @param {} [UNKNOWN_PARAMETER_NAME3] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {} [UNKNOWN_PARAMETER_NAME4] Property name for searching
         * @param {} [UNKNOWN_PARAMETER_NAME5] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsByProjectId(projectId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<WorkItemShortModel>> {
            return localVarFp.getWorkItemsByProjectId(projectId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System updates project  <br>System returns no content response
         * @summary Import to existing Project from json file.  Sections can be imported in only one target project!
         * @param {string} projectId 
         * @param {string} [apiVersion] 
         * @param {boolean} [includeAttachments] 
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importToExistingProject(projectId: string, apiVersion?: string, includeAttachments?: boolean, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.importToExistingProject(projectId, apiVersion, includeAttachments, file, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and restores deleted project  <br>System returns no content response
         * @summary Restore Project by Id or GlobalId
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project internal or global identifier and attribute model  <br>User runs method execution  <br>System updates project and project attribute for test plan  <br>System returns no content response
         * @summary Update project attribute for test plan
         * @param {string} projectId 
         * @param {CustomAttributeTestPlanProjectRelationPutModel} [customAttributeTestPlanProjectRelationPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomAttributeTestPlanProjectRelations(projectId: string, customAttributeTestPlanProjectRelationPutModel?: CustomAttributeTestPlanProjectRelationPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateCustomAttributeTestPlanProjectRelations(projectId, customAttributeTestPlanProjectRelationPutModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System returns updated project model (example listed in response parameters)
         * @summary Update Project
         * @param {ProjectPutModel} [projectPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectPutModel?: ProjectPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateProject(projectPutModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System updates attribute related to the project  <br>System returns no content response
         * @summary Update Projects Attribute
         * @param {string} projectId Project internal(guid format) or global(int  format) identifier
         * @param {CustomAttributeModel} [customAttributeModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectsAttribute(projectId: string, customAttributeModel?: CustomAttributeModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateProjectsAttribute(projectId, customAttributeModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections and                      workitems                  
     * @summary Export Project with tests, sections and configurations in json file
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [includeAttachments] 
     * @param {ProjectExportQueryModel} [projectExportQueryModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public _export(projectId: string, includeAttachments?: boolean, projectExportQueryModel?: ProjectExportQueryModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration)._export(projectId, includeAttachments, projectExportQueryModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System creates project  <br>System returns no content response
     * @summary Import Project from json file  Project can be imported only once (this method or ImportToExistingProject)  Next import will sync content in previously imported project.
     * @param {string} [apiVersion] 
     * @param {boolean} [includeAttachments] 
     * @param {File} [file] Select file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public _import(apiVersion?: string, includeAttachments?: boolean, file?: File, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration)._import(apiVersion, includeAttachments, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and attributes identifiers  <br>User runs method execution  <br>System updates project and add attributes to project for test plans  <br>System returns no content response
     * @summary Add attributes to project for test plans
     * @param {string} projectId 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createCustomAttributeTestPlanProjectRelations(projectId: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createCustomAttributeTestPlanProjectRelations(projectId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System creates project  <br>System returns project model (example listed in response parameters)
     * @summary Create Project
     * @param {ProjectPostModel} [projectPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(projectPostModel?: ProjectPostModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(projectPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets attribute parameters (listed in request example) and runs method execution  <br>System search project  <br>System creates attribute and relates it to the project  <br>System returns project attribute properties (example listed in response parameters)
     * @summary Create Projects Attribute
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {CustomAttributePostModel} [customAttributePostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectsAttribute(projectId: string, customAttributePostModel?: CustomAttributePostModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProjectsAttribute(projectId, customAttributePostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and attribute identifier  <br>User runs method execution  <br>System updates project and delete attribute from project for test plans  <br>System returns no content response
     * @summary Delete attribute from project for test plans
     * @param {string} projectId 
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteCustomAttributeTestPlanProjectRelations(projectId: string, attributeId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteCustomAttributeTestPlanProjectRelations(projectId, attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and delete project  <br>System returns no content response
     * @summary Delete Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier   <br>User runs method execution  <br>System delete all autotests from project  <br>System returns no content response
     * @summary Delete all AutoTests from Project
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectAutoTests(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectAutoTests(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project identifier and runs method execution  <br>User sets attribute identifier  <br>User runs method execution  <br>System search project  <br>System search and delete attribute  <br>System returns no content response
     * @summary Delete Projects Attribute by Id
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {string} attributeId Project attribute internal(guid format)  identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectsAttribute(projectId: string, attributeId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectsAttribute(projectId, attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>                      System returns project data as json file, containing project data, related attributes, sections, workitems,                      test plans, test suites, test points and configurations                  
     * @summary Export Project with tests, sections, configurations, testPlans, testSuites and testPoints as json file
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [includeAttachments] 
     * @param {ProjectExportWithTestPlansPostModel} [projectExportWithTestPlansPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public exportWithTestPlansAndConfigurations(projectId: string, includeAttachments?: boolean, projectExportWithTestPlansPostModel?: ProjectExportWithTestPlansPostModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).exportWithTestPlansAndConfigurations(projectId, includeAttachments, projectExportWithTestPlansPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>[Optional] User sets isDeleted field value  <br>[Optional] If User sets isDeleted field value as true, System search all deleted projects  <br>[Optional] If User sets isDeleted field value as false, System search all projects which are not deleted  <br>If User did not set isDeleted field value, System search all projects  <br>System returns array of all found projects(listed in response model)
     * @summary Get all Projects (if isDeleted is true, return deleted Projects)
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted projects
     * @param {string} [projectName] 
     * @param {} [UNKNOWN_PARAMETER_NAME] Amount of items to be skipped (offset)
     * @param {} [UNKNOWN_PARAMETER_NAME2] Amount of items to be taken (limit)
     * @param {} [UNKNOWN_PARAMETER_NAME3] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {} [UNKNOWN_PARAMETER_NAME4] Property name for searching
     * @param {} [UNKNOWN_PARAMETER_NAME5] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getAllProjects(isDeleted?: boolean, projectName?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getAllProjects(isDeleted, projectName, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>User sets project attribute identifier  <br>User runs method execution  <br>System search project  <br>System search project attribute   <br>System returns project attribute (listed in response model)
     * @summary Get Projects Attribute by Id
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {string} attributeId Project attribute internal(guid format)  identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getAttributeByProjectId(projectId: string, attributeId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getAttributeByProjectId(projectId, attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted attributes related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all attributes related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all attributes related to project  <br>System returns array of found attributes (listed in response model)
     * @summary Get Projects Attributes by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getAttributesByProjectId(projectId: string, isDeleted?: boolean, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getAttributesByProjectId(projectId, isDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all autotest related to the project  <br>System returns array of autotest with namespaces and classnames (listed in response)
     * @summary Get AutoTests Namespaces for Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getAutoTestsNamespaces(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getAutoTestsNamespaces(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all configurations related to project  <br>System returns array of found configurations (listed in response model)
     * @summary Get Configurations for Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getConfigurationsByProjectId(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getConfigurationsByProjectId(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User runs method execution  <br>System returns project for test plans attributes by project identifier
     * @summary Get project for test plans attributes
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getCustomAttributeTestPlanProjectRelations(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getCustomAttributeTestPlanProjectRelations(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System returns project (example listed in response parameters)
     * @summary Get Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectById(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjectById(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search project  <br>System search all sections related to the project  <br>System returns array of sections (listed in response)
     * @summary Get Sections for Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getSectionsByProjectId(projectId: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getSectionsByProjectId(projectId, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>                      [Optional] If User sets isDeleted field value as true, System search all deleted test plans related to                      project                    <br>                      [Optional] If User sets isDeleted field value as false, System search all test plans related to project which                      are not deleted                    <br>[Optional] If User did not set isDeleted field value, System search all v related to project  <br>System returns array of found test plans (listed in response model)
     * @summary Get TestPlans for Project by Id or GlobalId (if isDeleted is true, return deleted TestPlans)
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted test plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getTestPlansByProjectId(projectId: string, isDeleted?: boolean, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getTestPlansByProjectId(projectId, isDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>User runs method execution  <br>System search project  <br>System search all test runs related to project  <br>System returns array of found test runs (listed in response model)
     * @summary Get TestRuns for Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [notStarted] 
     * @param {boolean} [inProgress] 
     * @param {boolean} [stopped] 
     * @param {boolean} [completed] 
     * @param {string} [createdDateFrom] 
     * @param {string} [createdDateTo] 
     * @param {string} [testPlanId] 
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getTestRunsByProjectId(projectId: string, notStarted?: boolean, inProgress?: boolean, stopped?: boolean, completed?: boolean, createdDateFrom?: string, createdDateTo?: string, testPlanId?: string, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getTestRunsByProjectId(projectId, notStarted, inProgress, stopped, completed, createdDateFrom, createdDateTo, testPlanId, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier  <br>[Optional] User sets isDeleted field value  <br>User runs method execution  <br>System search project  <br>[Optional] If User sets isDeleted field value as true, System search all deleted workitems related to project  <br>                      [Optional] If User sets isDeleted field value as false, System search all workitems related to project which                      are not deleted                    <br>If User did not set isDeleted field value, System search all  workitems related to project  <br>System returns array of found workitems (listed in response model)
     * @summary Get WorkItems for Project by Id or GlobalId (if isDeleted is true, return deleted WorkItems)
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {boolean} [isDeleted] Boolean flag which defines if search must include deleted workitems
     * @param {Array<string>} [tagNames] Array of workitem tag names
     * @param {boolean} [includeIterations] 
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getWorkItemsByProjectId(projectId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getWorkItemsByProjectId(projectId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User attaches project as json file taken from export or export-by-testPlans method  <br>User runs method execution  <br>System updates project  <br>System returns no content response
     * @summary Import to existing Project from json file.  Sections can be imported in only one target project!
     * @param {string} projectId 
     * @param {string} [apiVersion] 
     * @param {boolean} [includeAttachments] 
     * @param {File} [file] Select file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public importToExistingProject(projectId: string, apiVersion?: string, includeAttachments?: boolean, file?: File, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).importToExistingProject(projectId, apiVersion, includeAttachments, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and runs method execution  <br>System search and restores deleted project  <br>System returns no content response
     * @summary Restore Project by Id or GlobalId
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public restoreProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).restoreProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project internal or global identifier and attribute model  <br>User runs method execution  <br>System updates project and project attribute for test plan  <br>System returns no content response
     * @summary Update project attribute for test plan
     * @param {string} projectId 
     * @param {CustomAttributeTestPlanProjectRelationPutModel} [customAttributeTestPlanProjectRelationPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateCustomAttributeTestPlanProjectRelations(projectId: string, customAttributeTestPlanProjectRelationPutModel?: CustomAttributeTestPlanProjectRelationPutModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateCustomAttributeTestPlanProjectRelations(projectId, customAttributeTestPlanProjectRelationPutModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System returns updated project model (example listed in response parameters)
     * @summary Update Project
     * @param {ProjectPutModel} [projectPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectPutModel?: ProjectPutModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(projectPutModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets project parameters (listed in request example) and runs method execution  <br>System updates project  <br>System updates attribute related to the project  <br>System returns no content response
     * @summary Update Projects Attribute
     * @param {string} projectId Project internal(guid format) or global(int  format) identifier
     * @param {CustomAttributeModel} [customAttributeModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectsAttribute(projectId: string, customAttributeModel?: CustomAttributeModel, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProjectsAttribute(projectId, customAttributeModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SectionsApi - axios parameter creator
 * @export
 */
export const SectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System creates section property values  <br>System returns section (listed in response example)
         * @summary Create Section
         * @param {SectionPostModel} [sectionPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSection: async (sectionPostModel?: SectionPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sectionPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search and delete nested sections of the found section  <br>System search and delete workitems related to the found nested sections  <br>System deletes initial section and related workitem  <br>System returns no content response
         * @summary Delete Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection: async (sectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('deleteSection', 'sectionId', sectionId)
            const localVarPath = `/api/v2/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets section internal (guid format) identifier  <br>User runs method execution  <br>System search section by the section identifier  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns section
         * @summary Get Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted section must be include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionById: async (sectionId: string, isDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getSectionById', 'sectionId', sectionId)
            const localVarPath = `/api/v2/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search workitems related to the section  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns workitem collection
         * @summary Get WorkItems for Section (if isDeleted is true, return deleted WorkItems)
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsBySectionId: async (sectionId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getWorkItemsBySectionId', 'sectionId', sectionId)
            const localVarPath = `/api/v2/sections/{sectionId}/workItems`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (tagNames) {
                localVarQueryParameter['tagNames'] = tagNames;
            }

            if (includeIterations !== undefined) {
                localVarQueryParameter['includeIterations'] = includeIterations;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>                      User sets section identifier, old parent identifier, parent identifier and  next section identifier (listed                      in request example)                    <br>User runs method execution  <br>System search section by the identifier  <br>System unlink section from the old parent and links to the new one  <br>System updates section rank using the next section identifier  <br>System returns no content response
         * @summary Move Section. Can be moved inside another section. It is possible to indicate a project
         * @param {SectionMoveModel} [sectionMoveModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (sectionMoveModel?: SectionMoveModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sections/move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sectionMoveModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets section identifier and new name (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section name using the new name  <br>System returns no content response
         * @summary Rename Section
         * @param {SectionRenameModel} [sectionRenameModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename: async (sectionRenameModel?: SectionRenameModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sections/rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sectionRenameModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section using the property values  <br>System returns no content response
         * @summary Update Section
         * @param {SectionPutModel} [sectionPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection: async (sectionPutModel?: SectionPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sectionPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectionsApi - functional programming interface
 * @export
 */
export const SectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System creates section property values  <br>System returns section (listed in response example)
         * @summary Create Section
         * @param {SectionPostModel} [sectionPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSection(sectionPostModel?: SectionPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionWithStepsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSection(sectionPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search and delete nested sections of the found section  <br>System search and delete workitems related to the found nested sections  <br>System deletes initial section and related workitem  <br>System returns no content response
         * @summary Delete Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSection(sectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSection(sectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets section internal (guid format) identifier  <br>User runs method execution  <br>System search section by the section identifier  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns section
         * @summary Get Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted section must be include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSectionById(sectionId: string, isDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SectionWithStepsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSectionById(sectionId, isDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search workitems related to the section  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns workitem collection
         * @summary Get WorkItems for Section (if isDeleted is true, return deleted WorkItems)
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsBySectionId(sectionId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsBySectionId(sectionId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>                      User sets section identifier, old parent identifier, parent identifier and  next section identifier (listed                      in request example)                    <br>User runs method execution  <br>System search section by the identifier  <br>System unlink section from the old parent and links to the new one  <br>System updates section rank using the next section identifier  <br>System returns no content response
         * @summary Move Section. Can be moved inside another section. It is possible to indicate a project
         * @param {SectionMoveModel} [sectionMoveModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(sectionMoveModel?: SectionMoveModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(sectionMoveModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets section identifier and new name (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section name using the new name  <br>System returns no content response
         * @summary Rename Section
         * @param {SectionRenameModel} [sectionRenameModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rename(sectionRenameModel?: SectionRenameModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rename(sectionRenameModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section using the property values  <br>System returns no content response
         * @summary Update Section
         * @param {SectionPutModel} [sectionPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSection(sectionPutModel?: SectionPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSection(sectionPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SectionsApi - factory interface
 * @export
 */
export const SectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SectionsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System creates section property values  <br>System returns section (listed in response example)
         * @summary Create Section
         * @param {SectionPostModel} [sectionPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSection(sectionPostModel?: SectionPostModel, options?: any): AxiosPromise<SectionWithStepsModel> {
            return localVarFp.createSection(sectionPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search and delete nested sections of the found section  <br>System search and delete workitems related to the found nested sections  <br>System deletes initial section and related workitem  <br>System returns no content response
         * @summary Delete Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection(sectionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSection(sectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets section internal (guid format) identifier  <br>User runs method execution  <br>System search section by the section identifier  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns section
         * @summary Get Section by id
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted section must be include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSectionById(sectionId: string, isDeleted?: boolean, options?: any): AxiosPromise<SectionWithStepsModel> {
            return localVarFp.getSectionById(sectionId, isDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search workitems related to the section  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns workitem collection
         * @summary Get WorkItems for Section (if isDeleted is true, return deleted WorkItems)
         * @param {string} sectionId Section internal (guid format) identifier
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {boolean} [includeIterations] 
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsBySectionId(sectionId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<WorkItemShortModel>> {
            return localVarFp.getWorkItemsBySectionId(sectionId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>                      User sets section identifier, old parent identifier, parent identifier and  next section identifier (listed                      in request example)                    <br>User runs method execution  <br>System search section by the identifier  <br>System unlink section from the old parent and links to the new one  <br>System updates section rank using the next section identifier  <br>System returns no content response
         * @summary Move Section. Can be moved inside another section. It is possible to indicate a project
         * @param {SectionMoveModel} [sectionMoveModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(sectionMoveModel?: SectionMoveModel, options?: any): AxiosPromise<void> {
            return localVarFp.move(sectionMoveModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets section identifier and new name (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section name using the new name  <br>System returns no content response
         * @summary Rename Section
         * @param {SectionRenameModel} [sectionRenameModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(sectionRenameModel?: SectionRenameModel, options?: any): AxiosPromise<void> {
            return localVarFp.rename(sectionRenameModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section using the property values  <br>System returns no content response
         * @summary Update Section
         * @param {SectionPutModel} [sectionPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection(sectionPutModel?: SectionPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateSection(sectionPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SectionsApi - object-oriented interface
 * @export
 * @class SectionsApi
 * @extends {BaseAPI}
 */
export class SectionsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System creates section property values  <br>System returns section (listed in response example)
     * @summary Create Section
     * @param {SectionPostModel} [sectionPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public createSection(sectionPostModel?: SectionPostModel, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).createSection(sectionPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search and delete nested sections of the found section  <br>System search and delete workitems related to the found nested sections  <br>System deletes initial section and related workitem  <br>System returns no content response
     * @summary Delete Section by id
     * @param {string} sectionId Section internal (guid format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public deleteSection(sectionId: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).deleteSection(sectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets section internal (guid format) identifier  <br>User runs method execution  <br>System search section by the section identifier  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns section
     * @summary Get Section by id
     * @param {string} sectionId Section internal (guid format) identifier
     * @param {boolean} [isDeleted] Flag that defines if deleted section must be include in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getSectionById(sectionId: string, isDeleted?: boolean, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getSectionById(sectionId, isDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets section identifier  <br>User runs method execution  <br>System search section by the identifier  <br>System search workitems related to the section  <br>                      [Optional] If isDeleted flag equals false, deleted workitems are not being searched.                      If true, deleted workitems are also being searched, null for all workitems.                    <br>System returns workitem collection
     * @summary Get WorkItems for Section (if isDeleted is true, return deleted WorkItems)
     * @param {string} sectionId Section internal (guid format) identifier
     * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
     * @param {Array<string>} [tagNames] Array of workitem tag names
     * @param {boolean} [includeIterations] 
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public getWorkItemsBySectionId(sectionId: string, isDeleted?: boolean, tagNames?: Array<string>, includeIterations?: boolean, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).getWorkItemsBySectionId(sectionId, isDeleted, tagNames, includeIterations, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>                      User sets section identifier, old parent identifier, parent identifier and  next section identifier (listed                      in request example)                    <br>User runs method execution  <br>System search section by the identifier  <br>System unlink section from the old parent and links to the new one  <br>System updates section rank using the next section identifier  <br>System returns no content response
     * @summary Move Section. Can be moved inside another section. It is possible to indicate a project
     * @param {SectionMoveModel} [sectionMoveModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public move(sectionMoveModel?: SectionMoveModel, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).move(sectionMoveModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets section identifier and new name (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section name using the new name  <br>System returns no content response
     * @summary Rename Section
     * @param {SectionRenameModel} [sectionRenameModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public rename(sectionRenameModel?: SectionRenameModel, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).rename(sectionRenameModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets section properties (listed in request example)  <br>User runs method execution  <br>System search section by the identifier  <br>System updates section using the property values  <br>System returns no content response
     * @summary Update Section
     * @param {SectionPutModel} [sectionPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionsApi
     */
    public updateSection(sectionPutModel?: SectionPutModel, options?: AxiosRequestConfig) {
        return SectionsApiFp(this.configuration).updateSection(sectionPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestPlansApi - axios parameter creator
 * @export
 */
export const TestPlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add test-points to test suite with sections
         * @param {string} testPlanId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestPointsWithSections: async (testPlanId: string, workItemSelectModel?: WorkItemSelectModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('addTestPointsWithSections', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/test-points/withSections`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemSelectModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets TestPlan identifier  <br>User sets WorkItem identifiers (listed in request example)  <br>User runs method execution  <br>System added WorkItems and Sections to TestPlan  <br>System returns no content response
         * @summary Add WorkItems to TestPlan with Sections as TestSuites
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {Set<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkItemsWithSections: async (testPlanId: string, requestBody?: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('addWorkItemsWithSections', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/workItems/withSections`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System clones test plan  <br>System returns test plan (listed in response example)
         * @summary Clone TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clone: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('clone', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/clone`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System completes the test plan and updates test plan status  <br>System returns no content response
         * @summary Complete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('complete', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/complete`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan properties (listed in request example)  <br>User runs method execution  <br>System creates test plan  <br>System returns test plan (listed in response example)
         * @summary Create TestPlan
         * @param {TestPlanPostModel} [testPlanPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestPlan: async (testPlanPostModel?: TestPlanPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testPlans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testPlanPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System delete test plan  <br>System returns no content response
         * @summary Delete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestPlan: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('deleteTestPlan', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System search  test plan by the identifier  <br>System returns test plan
         * @summary Get TestPlan by Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPlanById: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('getTestPlanById', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System finds test suites related to the test plan  <br>System returns test suites as a tree model (listed in response example)
         * @summary Get TestSuites Tree By Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestSuitesById: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('getTestSuitesById', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/testSuites`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System pauses the test plan and updates test plan status  <br>System returns no content response
         * @summary Pause TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('pause', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/pause`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System restores test plan  <br>System returns no content response
         * @summary Restore TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTestPlan: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('restoreTestPlan', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/restore`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System starts the test plan and updates test plan status  <br>System returns no content response
         * @summary Start TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: async (testPlanId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPlanId' is not null or undefined
            assertParamExists('start', 'testPlanId', testPlanId)
            const localVarPath = `/api/v2/testPlans/{testPlanId}/start`
                .replace(`{${"testPlanId"}}`, encodeURIComponent(String(testPlanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test plan properties(listed in request example)  <br>User runs method execution  <br>System updates test plan  <br>System returns no content response
         * @summary Update TestPlan
         * @param {TestPlanPutModel} [testPlanPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestPlan: async (testPlanPutModel?: TestPlanPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testPlans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testPlanPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestPlansApi - functional programming interface
 * @export
 */
export const TestPlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestPlansApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add test-points to test suite with sections
         * @param {string} testPlanId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTestPointsWithSections(testPlanId: string, workItemSelectModel?: WorkItemSelectModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTestPointsWithSections(testPlanId, workItemSelectModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets TestPlan identifier  <br>User sets WorkItem identifiers (listed in request example)  <br>User runs method execution  <br>System added WorkItems and Sections to TestPlan  <br>System returns no content response
         * @summary Add WorkItems to TestPlan with Sections as TestSuites
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {Set<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkItemsWithSections(testPlanId: string, requestBody?: Set<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkItemsWithSections(testPlanId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System clones test plan  <br>System returns test plan (listed in response example)
         * @summary Clone TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clone(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestPlanModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clone(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System completes the test plan and updates test plan status  <br>System returns no content response
         * @summary Complete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async complete(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.complete(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan properties (listed in request example)  <br>User runs method execution  <br>System creates test plan  <br>System returns test plan (listed in response example)
         * @summary Create TestPlan
         * @param {TestPlanPostModel} [testPlanPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTestPlan(testPlanPostModel?: TestPlanPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestPlanModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTestPlan(testPlanPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System delete test plan  <br>System returns no content response
         * @summary Delete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTestPlan(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTestPlan(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System search  test plan by the identifier  <br>System returns test plan
         * @summary Get TestPlan by Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestPlanById(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestPlanModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestPlanById(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System finds test suites related to the test plan  <br>System returns test suites as a tree model (listed in response example)
         * @summary Get TestSuites Tree By Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestSuitesById(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestSuiteV2TreeModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestSuitesById(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System pauses the test plan and updates test plan status  <br>System returns no content response
         * @summary Pause TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pause(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pause(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System restores test plan  <br>System returns no content response
         * @summary Restore TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreTestPlan(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreTestPlan(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System starts the test plan and updates test plan status  <br>System returns no content response
         * @summary Start TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async start(testPlanId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.start(testPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test plan properties(listed in request example)  <br>User runs method execution  <br>System updates test plan  <br>System returns no content response
         * @summary Update TestPlan
         * @param {TestPlanPutModel} [testPlanPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTestPlan(testPlanPutModel?: TestPlanPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTestPlan(testPlanPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestPlansApi - factory interface
 * @export
 */
export const TestPlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestPlansApiFp(configuration)
    return {
        /**
         * 
         * @summary Add test-points to test suite with sections
         * @param {string} testPlanId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestPointsWithSections(testPlanId: string, workItemSelectModel?: WorkItemSelectModel, options?: any): AxiosPromise<void> {
            return localVarFp.addTestPointsWithSections(testPlanId, workItemSelectModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets TestPlan identifier  <br>User sets WorkItem identifiers (listed in request example)  <br>User runs method execution  <br>System added WorkItems and Sections to TestPlan  <br>System returns no content response
         * @summary Add WorkItems to TestPlan with Sections as TestSuites
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {Set<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkItemsWithSections(testPlanId: string, requestBody?: Set<string>, options?: any): AxiosPromise<void> {
            return localVarFp.addWorkItemsWithSections(testPlanId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System clones test plan  <br>System returns test plan (listed in response example)
         * @summary Clone TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clone(testPlanId: string, options?: any): AxiosPromise<TestPlanModel> {
            return localVarFp.clone(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System completes the test plan and updates test plan status  <br>System returns no content response
         * @summary Complete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(testPlanId: string, options?: any): AxiosPromise<void> {
            return localVarFp.complete(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan properties (listed in request example)  <br>User runs method execution  <br>System creates test plan  <br>System returns test plan (listed in response example)
         * @summary Create TestPlan
         * @param {TestPlanPostModel} [testPlanPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestPlan(testPlanPostModel?: TestPlanPostModel, options?: any): AxiosPromise<TestPlanModel> {
            return localVarFp.createTestPlan(testPlanPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System delete test plan  <br>System returns no content response
         * @summary Delete TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestPlan(testPlanId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTestPlan(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System search  test plan by the identifier  <br>System returns test plan
         * @summary Get TestPlan by Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPlanById(testPlanId: string, options?: any): AxiosPromise<TestPlanModel> {
            return localVarFp.getTestPlanById(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System finds test suites related to the test plan  <br>System returns test suites as a tree model (listed in response example)
         * @summary Get TestSuites Tree By Id
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestSuitesById(testPlanId: string, options?: any): AxiosPromise<Array<TestSuiteV2TreeModel>> {
            return localVarFp.getTestSuitesById(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System pauses the test plan and updates test plan status  <br>System returns no content response
         * @summary Pause TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(testPlanId: string, options?: any): AxiosPromise<void> {
            return localVarFp.pause(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System restores test plan  <br>System returns no content response
         * @summary Restore TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTestPlan(testPlanId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreTestPlan(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System starts the test plan and updates test plan status  <br>System returns no content response
         * @summary Start TestPlan
         * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(testPlanId: string, options?: any): AxiosPromise<void> {
            return localVarFp.start(testPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test plan properties(listed in request example)  <br>User runs method execution  <br>System updates test plan  <br>System returns no content response
         * @summary Update TestPlan
         * @param {TestPlanPutModel} [testPlanPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestPlan(testPlanPutModel?: TestPlanPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateTestPlan(testPlanPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestPlansApi - object-oriented interface
 * @export
 * @class TestPlansApi
 * @extends {BaseAPI}
 */
export class TestPlansApi extends BaseAPI {
    /**
     * 
     * @summary Add test-points to test suite with sections
     * @param {string} testPlanId Test suite internal identifier
     * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public addTestPointsWithSections(testPlanId: string, workItemSelectModel?: WorkItemSelectModel, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).addTestPointsWithSections(testPlanId, workItemSelectModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets TestPlan identifier  <br>User sets WorkItem identifiers (listed in request example)  <br>User runs method execution  <br>System added WorkItems and Sections to TestPlan  <br>System returns no content response
     * @summary Add WorkItems to TestPlan with Sections as TestSuites
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {Set<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public addWorkItemsWithSections(testPlanId: string, requestBody?: Set<string>, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).addWorkItemsWithSections(testPlanId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System clones test plan  <br>System returns test plan (listed in response example)
     * @summary Clone TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public clone(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).clone(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System completes the test plan and updates test plan status  <br>System returns no content response
     * @summary Complete TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public complete(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).complete(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan properties (listed in request example)  <br>User runs method execution  <br>System creates test plan  <br>System returns test plan (listed in response example)
     * @summary Create TestPlan
     * @param {TestPlanPostModel} [testPlanPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public createTestPlan(testPlanPostModel?: TestPlanPostModel, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).createTestPlan(testPlanPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System delete test plan  <br>System returns no content response
     * @summary Delete TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public deleteTestPlan(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).deleteTestPlan(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System search  test plan by the identifier  <br>System returns test plan
     * @summary Get TestPlan by Id
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public getTestPlanById(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).getTestPlanById(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System finds test suites related to the test plan  <br>System returns test suites as a tree model (listed in response example)
     * @summary Get TestSuites Tree By Id
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public getTestSuitesById(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).getTestSuitesById(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System pauses the test plan and updates test plan status  <br>System returns no content response
     * @summary Pause TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public pause(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).pause(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System restores test plan  <br>System returns no content response
     * @summary Restore TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public restoreTestPlan(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).restoreTestPlan(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan identifier  <br>User runs method execution  <br>System starts the test plan and updates test plan status  <br>System returns no content response
     * @summary Start TestPlan
     * @param {string} testPlanId Test plan internal (guid format) or global (int  format) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public start(testPlanId: string, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).start(testPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test plan properties(listed in request example)  <br>User runs method execution  <br>System updates test plan  <br>System returns no content response
     * @summary Update TestPlan
     * @param {TestPlanPutModel} [testPlanPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlansApi
     */
    public updateTestPlan(testPlanPutModel?: TestPlanPutModel, options?: AxiosRequestConfig) {
        return TestPlansApiFp(this.configuration).updateTestPlan(testPlanPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestResultsApi - axios parameter creator
 * @export
 */
export const TestResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets testResultId  <br>User attaches a file  <br>System creates attachment and links it to the test result  <br>System returns attachment identifier
         * @summary Upload and link attachment to TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment: async (testResultId: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testResultId' is not null or undefined
            assertParamExists('createAttachment', 'testResultId', testResultId)
            const localVarPath = `/api/v2/testResults/{testResultId}/attachments`
                .replace(`{${"testResultId"}}`, encodeURIComponent(String(testResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets testResultId and attachmentId  <br>User attaches a file  <br>User runs method execution  <br>System deletes attachment and unlinks it from the test result  <br>System returns attachment identifier
         * @summary Remove attachment and unlink from TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (testResultId: string, attachmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testResultId' is not null or undefined
            assertParamExists('deleteAttachment', 'testResultId', testResultId)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('deleteAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/api/v2/testResults/{testResultId}/attachments/{attachmentId}`
                .replace(`{${"testResultId"}}`, encodeURIComponent(String(testResultId)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>[Optional] User sets resize configuration  <br>User runs method execution  <br>System search attachments by the attachmentId and the testResultId  <br>                      [Optional] If resize configuration is set, System resizes the attachment according to the resize                      configuration                    <br>[Optional] Otherwise, System does not resize the attachment  <br>System returns attachment as a file
         * @summary Get attachment of TestResult
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {ImageResizeOption} [resizeOption] 
         * @param {string} [backgroundColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: async (attachmentId: string, testResultId: string, width?: number, height?: number, resizeOption?: ImageResizeOption, backgroundColor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('downloadAttachment', 'attachmentId', attachmentId)
            // verify required parameter 'testResultId' is not null or undefined
            assertParamExists('downloadAttachment', 'testResultId', testResultId)
            const localVarPath = `/api/v2/testResults/{testResultId}/attachments/{attachmentId}`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"testResultId"}}`, encodeURIComponent(String(testResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (resizeOption !== undefined) {
                localVarQueryParameter['ResizeOption'] = resizeOption;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>User runs method execution  <br>System search attachment by the attachmentId and the testResultId  <br>System returns attachment data
         * @summary Get Metadata of TestResult\'s attachment
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (attachmentId: string, testResultId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('getAttachment', 'attachmentId', attachmentId)
            // verify required parameter 'testResultId' is not null or undefined
            assertParamExists('getAttachment', 'testResultId', testResultId)
            const localVarPath = `/api/v2/testResults/{testResultId}/attachments/{attachmentId}/info`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"testResultId"}}`, encodeURIComponent(String(testResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets testResultId  <br>User runs method execution  <br>System search all attachments of the test result  <br>System returns attachments enumeration
         * @summary Get all attachments of TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (testResultId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testResultId' is not null or undefined
            assertParamExists('getAttachments', 'testResultId', testResultId)
            const localVarPath = `/api/v2/testResults/{testResultId}/attachments`
                .replace(`{${"testResultId"}}`, encodeURIComponent(String(testResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set result for AutoTest (Obsolete).  The new endpoint is [POST]/api/v2/testRuns/{testRunId}/testResults
         * @param {AutoTestResultPostModel} [autoTestResultPostModel] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setAutoTestResults: async (autoTestResultPostModel?: AutoTestResultPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testResults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestResultPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestResultsApi - functional programming interface
 * @export
 */
export const TestResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets testResultId  <br>User attaches a file  <br>System creates attachment and links it to the test result  <br>System returns attachment identifier
         * @summary Upload and link attachment to TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment(testResultId: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(testResultId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets testResultId and attachmentId  <br>User attaches a file  <br>User runs method execution  <br>System deletes attachment and unlinks it from the test result  <br>System returns attachment identifier
         * @summary Remove attachment and unlink from TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(testResultId: string, attachmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(testResultId, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>[Optional] User sets resize configuration  <br>User runs method execution  <br>System search attachments by the attachmentId and the testResultId  <br>                      [Optional] If resize configuration is set, System resizes the attachment according to the resize                      configuration                    <br>[Optional] Otherwise, System does not resize the attachment  <br>System returns attachment as a file
         * @summary Get attachment of TestResult
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {ImageResizeOption} [resizeOption] 
         * @param {string} [backgroundColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAttachment(attachmentId: string, testResultId: string, width?: number, height?: number, resizeOption?: ImageResizeOption, backgroundColor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAttachment(attachmentId, testResultId, width, height, resizeOption, backgroundColor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>User runs method execution  <br>System search attachment by the attachmentId and the testResultId  <br>System returns attachment data
         * @summary Get Metadata of TestResult\'s attachment
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(attachmentId: string, testResultId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(attachmentId, testResultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets testResultId  <br>User runs method execution  <br>System search all attachments of the test result  <br>System returns attachments enumeration
         * @summary Get all attachments of TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(testResultId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttachmentModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(testResultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set result for AutoTest (Obsolete).  The new endpoint is [POST]/api/v2/testRuns/{testRunId}/testResults
         * @param {AutoTestResultPostModel} [autoTestResultPostModel] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async setAutoTestResults(autoTestResultPostModel?: AutoTestResultPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAutoTestResults(autoTestResultPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestResultsApi - factory interface
 * @export
 */
export const TestResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestResultsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets testResultId  <br>User attaches a file  <br>System creates attachment and links it to the test result  <br>System returns attachment identifier
         * @summary Upload and link attachment to TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {File} [file] Select file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(testResultId: string, file?: File, options?: any): AxiosPromise<string> {
            return localVarFp.createAttachment(testResultId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets testResultId and attachmentId  <br>User attaches a file  <br>User runs method execution  <br>System deletes attachment and unlinks it from the test result  <br>System returns attachment identifier
         * @summary Remove attachment and unlink from TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(testResultId: string, attachmentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(testResultId, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>[Optional] User sets resize configuration  <br>User runs method execution  <br>System search attachments by the attachmentId and the testResultId  <br>                      [Optional] If resize configuration is set, System resizes the attachment according to the resize                      configuration                    <br>[Optional] Otherwise, System does not resize the attachment  <br>System returns attachment as a file
         * @summary Get attachment of TestResult
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {ImageResizeOption} [resizeOption] 
         * @param {string} [backgroundColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(attachmentId: string, testResultId: string, width?: number, height?: number, resizeOption?: ImageResizeOption, backgroundColor?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadAttachment(attachmentId, testResultId, width, height, resizeOption, backgroundColor, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets attachmentId and testResultId  <br>User runs method execution  <br>System search attachment by the attachmentId and the testResultId  <br>System returns attachment data
         * @summary Get Metadata of TestResult\'s attachment
         * @param {string} attachmentId Attachment internal identifier (guid format)
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(attachmentId: string, testResultId: string, options?: any): AxiosPromise<AttachmentModel> {
            return localVarFp.getAttachment(attachmentId, testResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets testResultId  <br>User runs method execution  <br>System search all attachments of the test result  <br>System returns attachments enumeration
         * @summary Get all attachments of TestResult
         * @param {string} testResultId Test result internal identifier (guid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(testResultId: string, options?: any): AxiosPromise<Array<AttachmentModel>> {
            return localVarFp.getAttachments(testResultId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set result for AutoTest (Obsolete).  The new endpoint is [POST]/api/v2/testRuns/{testRunId}/testResults
         * @param {AutoTestResultPostModel} [autoTestResultPostModel] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setAutoTestResults(autoTestResultPostModel?: AutoTestResultPostModel, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.setAutoTestResults(autoTestResultPostModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestResultsApi - object-oriented interface
 * @export
 * @class TestResultsApi
 * @extends {BaseAPI}
 */
export class TestResultsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets testResultId  <br>User attaches a file  <br>System creates attachment and links it to the test result  <br>System returns attachment identifier
     * @summary Upload and link attachment to TestResult
     * @param {string} testResultId Test result internal identifier (guid format)
     * @param {File} [file] Select file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public createAttachment(testResultId: string, file?: File, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).createAttachment(testResultId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets testResultId and attachmentId  <br>User attaches a file  <br>User runs method execution  <br>System deletes attachment and unlinks it from the test result  <br>System returns attachment identifier
     * @summary Remove attachment and unlink from TestResult
     * @param {string} testResultId Test result internal identifier (guid format)
     * @param {string} attachmentId Attachment internal identifier (guid format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public deleteAttachment(testResultId: string, attachmentId: string, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).deleteAttachment(testResultId, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets attachmentId and testResultId  <br>[Optional] User sets resize configuration  <br>User runs method execution  <br>System search attachments by the attachmentId and the testResultId  <br>                      [Optional] If resize configuration is set, System resizes the attachment according to the resize                      configuration                    <br>[Optional] Otherwise, System does not resize the attachment  <br>System returns attachment as a file
     * @summary Get attachment of TestResult
     * @param {string} attachmentId Attachment internal identifier (guid format)
     * @param {string} testResultId Test result internal identifier (guid format)
     * @param {number} [width] 
     * @param {number} [height] 
     * @param {ImageResizeOption} [resizeOption] 
     * @param {string} [backgroundColor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public downloadAttachment(attachmentId: string, testResultId: string, width?: number, height?: number, resizeOption?: ImageResizeOption, backgroundColor?: string, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).downloadAttachment(attachmentId, testResultId, width, height, resizeOption, backgroundColor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets attachmentId and testResultId  <br>User runs method execution  <br>System search attachment by the attachmentId and the testResultId  <br>System returns attachment data
     * @summary Get Metadata of TestResult\'s attachment
     * @param {string} attachmentId Attachment internal identifier (guid format)
     * @param {string} testResultId Test result internal identifier (guid format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public getAttachment(attachmentId: string, testResultId: string, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).getAttachment(attachmentId, testResultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets testResultId  <br>User runs method execution  <br>System search all attachments of the test result  <br>System returns attachments enumeration
     * @summary Get all attachments of TestResult
     * @param {string} testResultId Test result internal identifier (guid format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public getAttachments(testResultId: string, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).getAttachments(testResultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set result for AutoTest (Obsolete).  The new endpoint is [POST]/api/v2/testRuns/{testRunId}/testResults
     * @param {AutoTestResultPostModel} [autoTestResultPostModel] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public setAutoTestResults(autoTestResultPostModel?: AutoTestResultPostModel, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).setAutoTestResults(autoTestResultPostModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestRunsApi - axios parameter creator
 * @export
 */
export const TestRunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System completes test run  <br>System returns no content response
         * @summary Complete TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTestRun: async (testRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRunId' is not null or undefined
            assertParamExists('completeTestRun', 'testRunId', testRunId)
            const localVarPath = `/api/v2/testRuns/{testRunId}/complete`
                .replace(`{${"testRunId"}}`, encodeURIComponent(String(testRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds autotests and configurations using ids listed by user  <br>System creates test result by test points which use autotests and configurations  <br>System returns test run model
         * @summary Create TestRun without TestPoints using ConfigurationIds and AutoTestIds
         * @param {TestRunFillByAutoTestsPostModel} [testRunFillByAutoTestsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByAutoTests: async (testRunFillByAutoTestsPostModel?: TestRunFillByAutoTestsPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testRuns/byAutoTests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRunFillByAutoTestsPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPointSelectors based on ConfigurationId and WorkItem Ids
         * @param {TestRunFillByConfigurationsPostModel} [testRunFillByConfigurationsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByConfigurations: async (testRunFillByConfigurationsPostModel?: TestRunFillByConfigurationsPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testRuns/byConfigurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRunFillByConfigurationsPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPoints selected using ConfigurationIds and WorkItem Ids
         * @param {TestRunFillByWorkItemsPostModel} [testRunFillByWorkItemsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByWorkItems: async (testRunFillByWorkItemsPostModel?: TestRunFillByWorkItemsPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testRuns/byWorkItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRunFillByWorkItemsPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run model (listed in the request example)  <br>User runs method execution  <br>System creates test run  <br>System returns test run model
         * @summary Create empty TestRun
         * @param {TestRunV2PostShortModel} [testRunV2PostShortModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmpty: async (testRunV2PostShortModel?: TestRunV2PostShortModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testRuns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRunV2PostShortModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System finds test run  <br>System returns test run
         * @summary Get TestRun by Id
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRunById: async (testRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRunId' is not null or undefined
            assertParamExists('getTestRunById', 'testRunId', testRunId)
            const localVarPath = `/api/v2/testRuns/{testRunId}`
                .replace(`{${"testRunId"}}`, encodeURIComponent(String(testRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User sets test result model (listed in request parameters)   <br>User runs method execution  <br>System sets test results of autotest listed in request in test run  <br>System returns array of test results identifiers
         * @summary Set AutoTest Results For TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {Array<AutoTestResultsForTestRunModel>} [autoTestResultsForTestRunModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoTestResultsForTestRun: async (testRunId: string, autoTestResultsForTestRunModel?: Array<AutoTestResultsForTestRunModel>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRunId' is not null or undefined
            assertParamExists('setAutoTestResultsForTestRun', 'testRunId', testRunId)
            const localVarPath = `/api/v2/testRuns/{testRunId}/testResults`
                .replace(`{${"testRunId"}}`, encodeURIComponent(String(testRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoTestResultsForTestRunModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System starts test run  <br>System returns no content response
         * @summary Start TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTestRun: async (testRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRunId' is not null or undefined
            assertParamExists('startTestRun', 'testRunId', testRunId)
            const localVarPath = `/api/v2/testRuns/{testRunId}/start`
                .replace(`{${"testRunId"}}`, encodeURIComponent(String(testRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System stops test run  <br>System returns no content response
         * @summary Stop TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTestRun: async (testRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testRunId' is not null or undefined
            assertParamExists('stopTestRun', 'testRunId', testRunId)
            const localVarPath = `/api/v2/testRuns/{testRunId}/stop`
                .replace(`{${"testRunId"}}`, encodeURIComponent(String(testRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User runs method execution  <br>System updates test run  <br>System returns returns no content response
         * @summary Update empty TestRun
         * @param {TestRunV2PutModel} [testRunV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmpty: async (testRunV2PutModel?: TestRunV2PutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testRuns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRunV2PutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestRunsApi - functional programming interface
 * @export
 */
export const TestRunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestRunsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System completes test run  <br>System returns no content response
         * @summary Complete TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTestRun(testRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTestRun(testRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds autotests and configurations using ids listed by user  <br>System creates test result by test points which use autotests and configurations  <br>System returns test run model
         * @summary Create TestRun without TestPoints using ConfigurationIds and AutoTestIds
         * @param {TestRunFillByAutoTestsPostModel} [testRunFillByAutoTestsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndFillByAutoTests(testRunFillByAutoTestsPostModel?: TestRunFillByAutoTestsPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndFillByAutoTests(testRunFillByAutoTestsPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPointSelectors based on ConfigurationId and WorkItem Ids
         * @param {TestRunFillByConfigurationsPostModel} [testRunFillByConfigurationsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndFillByConfigurations(testRunFillByConfigurationsPostModel?: TestRunFillByConfigurationsPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndFillByConfigurations(testRunFillByConfigurationsPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPoints selected using ConfigurationIds and WorkItem Ids
         * @param {TestRunFillByWorkItemsPostModel} [testRunFillByWorkItemsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndFillByWorkItems(testRunFillByWorkItemsPostModel?: TestRunFillByWorkItemsPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndFillByWorkItems(testRunFillByWorkItemsPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run model (listed in the request example)  <br>User runs method execution  <br>System creates test run  <br>System returns test run model
         * @summary Create empty TestRun
         * @param {TestRunV2PostShortModel} [testRunV2PostShortModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmpty(testRunV2PostShortModel?: TestRunV2PostShortModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmpty(testRunV2PostShortModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System finds test run  <br>System returns test run
         * @summary Get TestRun by Id
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestRunById(testRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestRunV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestRunById(testRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User sets test result model (listed in request parameters)   <br>User runs method execution  <br>System sets test results of autotest listed in request in test run  <br>System returns array of test results identifiers
         * @summary Set AutoTest Results For TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {Array<AutoTestResultsForTestRunModel>} [autoTestResultsForTestRunModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAutoTestResultsForTestRun(testRunId: string, autoTestResultsForTestRunModel?: Array<AutoTestResultsForTestRunModel>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAutoTestResultsForTestRun(testRunId, autoTestResultsForTestRunModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System starts test run  <br>System returns no content response
         * @summary Start TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTestRun(testRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTestRun(testRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System stops test run  <br>System returns no content response
         * @summary Stop TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTestRun(testRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTestRun(testRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User runs method execution  <br>System updates test run  <br>System returns returns no content response
         * @summary Update empty TestRun
         * @param {TestRunV2PutModel} [testRunV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmpty(testRunV2PutModel?: TestRunV2PutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmpty(testRunV2PutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestRunsApi - factory interface
 * @export
 */
export const TestRunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestRunsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System completes test run  <br>System returns no content response
         * @summary Complete TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTestRun(testRunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeTestRun(testRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds autotests and configurations using ids listed by user  <br>System creates test result by test points which use autotests and configurations  <br>System returns test run model
         * @summary Create TestRun without TestPoints using ConfigurationIds and AutoTestIds
         * @param {TestRunFillByAutoTestsPostModel} [testRunFillByAutoTestsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByAutoTests(testRunFillByAutoTestsPostModel?: TestRunFillByAutoTestsPostModel, options?: any): AxiosPromise<TestRunV2GetModel> {
            return localVarFp.createAndFillByAutoTests(testRunFillByAutoTestsPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPointSelectors based on ConfigurationId and WorkItem Ids
         * @param {TestRunFillByConfigurationsPostModel} [testRunFillByConfigurationsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByConfigurations(testRunFillByConfigurationsPostModel?: TestRunFillByConfigurationsPostModel, options?: any): AxiosPromise<TestRunV2GetModel> {
            return localVarFp.createAndFillByConfigurations(testRunFillByConfigurationsPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
         * @summary Create TestRun with TestPoints selected using ConfigurationIds and WorkItem Ids
         * @param {TestRunFillByWorkItemsPostModel} [testRunFillByWorkItemsPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndFillByWorkItems(testRunFillByWorkItemsPostModel?: TestRunFillByWorkItemsPostModel, options?: any): AxiosPromise<TestRunV2GetModel> {
            return localVarFp.createAndFillByWorkItems(testRunFillByWorkItemsPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run model (listed in the request example)  <br>User runs method execution  <br>System creates test run  <br>System returns test run model
         * @summary Create empty TestRun
         * @param {TestRunV2PostShortModel} [testRunV2PostShortModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmpty(testRunV2PostShortModel?: TestRunV2PostShortModel, options?: any): AxiosPromise<TestRunV2GetModel> {
            return localVarFp.createEmpty(testRunV2PostShortModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System finds test run  <br>System returns test run
         * @summary Get TestRun by Id
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestRunById(testRunId: string, options?: any): AxiosPromise<TestRunV2GetModel> {
            return localVarFp.getTestRunById(testRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User sets test result model (listed in request parameters)   <br>User runs method execution  <br>System sets test results of autotest listed in request in test run  <br>System returns array of test results identifiers
         * @summary Set AutoTest Results For TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {Array<AutoTestResultsForTestRunModel>} [autoTestResultsForTestRunModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoTestResultsForTestRun(testRunId: string, autoTestResultsForTestRunModel?: Array<AutoTestResultsForTestRunModel>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.setAutoTestResultsForTestRun(testRunId, autoTestResultsForTestRunModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System starts test run  <br>System returns no content response
         * @summary Start TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTestRun(testRunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.startTestRun(testRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System stops test run  <br>System returns no content response
         * @summary Stop TestRun
         * @param {string} testRunId Test Run internal identifier (GUID format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTestRun(testRunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.stopTestRun(testRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User runs method execution  <br>System updates test run  <br>System returns returns no content response
         * @summary Update empty TestRun
         * @param {TestRunV2PutModel} [testRunV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmpty(testRunV2PutModel?: TestRunV2PutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateEmpty(testRunV2PutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestRunsApi - object-oriented interface
 * @export
 * @class TestRunsApi
 * @extends {BaseAPI}
 */
export class TestRunsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System completes test run  <br>System returns no content response
     * @summary Complete TestRun
     * @param {string} testRunId Test Run internal identifier (GUID format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public completeTestRun(testRunId: string, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).completeTestRun(testRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds autotests and configurations using ids listed by user  <br>System creates test result by test points which use autotests and configurations  <br>System returns test run model
     * @summary Create TestRun without TestPoints using ConfigurationIds and AutoTestIds
     * @param {TestRunFillByAutoTestsPostModel} [testRunFillByAutoTestsPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public createAndFillByAutoTests(testRunFillByAutoTestsPostModel?: TestRunFillByAutoTestsPostModel, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).createAndFillByAutoTests(testRunFillByAutoTestsPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
     * @summary Create TestRun with TestPointSelectors based on ConfigurationId and WorkItem Ids
     * @param {TestRunFillByConfigurationsPostModel} [testRunFillByConfigurationsPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public createAndFillByConfigurations(testRunFillByConfigurationsPostModel?: TestRunFillByConfigurationsPostModel, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).createAndFillByConfigurations(testRunFillByConfigurationsPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User sets relative configuration and workitem ids  <br>User runs method execution  <br>System creates test run  <br>System finds workitems and configurations using ids listed by user  <br>System creates test result by test points which use workitems and configurations  <br>System returns test run model
     * @summary Create TestRun with TestPoints selected using ConfigurationIds and WorkItem Ids
     * @param {TestRunFillByWorkItemsPostModel} [testRunFillByWorkItemsPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public createAndFillByWorkItems(testRunFillByWorkItemsPostModel?: TestRunFillByWorkItemsPostModel, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).createAndFillByWorkItems(testRunFillByWorkItemsPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run model (listed in the request example)  <br>User runs method execution  <br>System creates test run  <br>System returns test run model
     * @summary Create empty TestRun
     * @param {TestRunV2PostShortModel} [testRunV2PostShortModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public createEmpty(testRunV2PostShortModel?: TestRunV2PostShortModel, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).createEmpty(testRunV2PostShortModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System finds test run  <br>System returns test run
     * @summary Get TestRun by Id
     * @param {string} testRunId Test Run internal identifier (GUID format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public getTestRunById(testRunId: string, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).getTestRunById(testRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run identifier  <br>User sets test result model (listed in request parameters)   <br>User runs method execution  <br>System sets test results of autotest listed in request in test run  <br>System returns array of test results identifiers
     * @summary Set AutoTest Results For TestRun
     * @param {string} testRunId Test Run internal identifier (GUID format)
     * @param {Array<AutoTestResultsForTestRunModel>} [autoTestResultsForTestRunModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public setAutoTestResultsForTestRun(testRunId: string, autoTestResultsForTestRunModel?: Array<AutoTestResultsForTestRunModel>, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).setAutoTestResultsForTestRun(testRunId, autoTestResultsForTestRunModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System starts test run  <br>System returns no content response
     * @summary Start TestRun
     * @param {string} testRunId Test Run internal identifier (GUID format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public startTestRun(testRunId: string, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).startTestRun(testRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run identifier  <br>User runs method execution  <br>System stops test run  <br>System returns no content response
     * @summary Stop TestRun
     * @param {string} testRunId Test Run internal identifier (GUID format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public stopTestRun(testRunId: string, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).stopTestRun(testRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test run properties (listed in the request example)  <br>User runs method execution  <br>System updates test run  <br>System returns returns no content response
     * @summary Update empty TestRun
     * @param {TestRunV2PutModel} [testRunV2PutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestRunsApi
     */
    public updateEmpty(testRunV2PutModel?: TestRunV2PutModel, options?: AxiosRequestConfig) {
        return TestRunsApiFp(this.configuration).updateEmpty(testRunV2PutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestSuitesApi - axios parameter creator
 * @export
 */
export const TestSuitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add test-points to test suite
         * @param {string} testSuiteId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestPointsToTestSuite: async (testSuiteId: string, workItemSelectModel?: WorkItemSelectModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('addTestPointsToTestSuite', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/test-points`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemSelectModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System creates test suite  <br>System returns test suite
         * @summary Create TestSuite
         * @param {TestSuiteV2PostModel} [testSuiteV2PostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestSuite: async (testSuiteV2PostModel?: TestSuiteV2PostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testSuites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testSuiteV2PostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System deletes test suite  <br>System returns no content response
         * @summary Delete TestSuite
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestSuite: async (testSuiteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('deleteTestSuite', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configurations related to the test points  <br>System returns configurations array
         * @summary Get Configurations By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationsByTestSuiteId: async (testSuiteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('getConfigurationsByTestSuiteId', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/configurations`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System returns test points array
         * @summary Get TestPoints By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPointsById: async (testSuiteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('getTestPointsById', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/testPoints`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search test results related to the test points  <br>System returns test results array
         * @summary Get TestResults By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsById: async (testSuiteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('getTestResultsById', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/testResults`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System returns test suite
         * @summary Get TestSuite by Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestSuiteById: async (testSuiteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('getTestSuiteById', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>[Optional] User sets isDeleted property as true  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems related to the test points  <br>                      [Optional] User sets isDeleted property is set as true, System includes deleted workitems                      Otherwise, system applies filter which excludes deleted workitems from all found workitems                    <br>System returns workitems array
         * @summary Get WorkItems By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsById: async (testSuiteId: string, isDeleted?: boolean, tagNames?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('getWorkItemsById', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/workItems`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            if (tagNames) {
                localVarQueryParameter['tagNames'] = tagNames;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['OrderBy'] = orderBy;
            }

            if (searchField !== undefined) {
                localVarQueryParameter['SearchField'] = searchField;
            }

            if (searchValue !== undefined) {
                localVarQueryParameter['SearchValue'] = searchValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of configuration identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configuration  <br>System restores(if exist) or creates test points with listed configuration  <br>System returns no content response
         * @summary Set Configurations By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of configuration identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigurationsByTestSuiteId: async (testSuiteId: string, requestBody?: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('setConfigurationsByTestSuiteId', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/configurations`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of workitems identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems  <br>System restores(if exist) or creates test points with listed workitems  <br>System returns no content response
         * @summary Set WorkItems By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of workitem identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkItemsByTestSuiteId: async (testSuiteId: string, requestBody?: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testSuiteId' is not null or undefined
            assertParamExists('setWorkItemsByTestSuiteId', 'testSuiteId', testSuiteId)
            const localVarPath = `/api/v2/testSuites/{testSuiteId}/workItems`
                .replace(`{${"testSuiteId"}}`, encodeURIComponent(String(testSuiteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System updates test suite  <br>System returns test suite
         * @summary Update TestSuite
         * @param {TestSuiteV2PutModel} [testSuiteV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestSuite: async (testSuiteV2PutModel?: TestSuiteV2PutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/testSuites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testSuiteV2PutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestSuitesApi - functional programming interface
 * @export
 */
export const TestSuitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestSuitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add test-points to test suite
         * @param {string} testSuiteId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTestPointsToTestSuite(testSuiteId: string, workItemSelectModel?: WorkItemSelectModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTestPointsToTestSuite(testSuiteId, workItemSelectModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System creates test suite  <br>System returns test suite
         * @summary Create TestSuite
         * @param {TestSuiteV2PostModel} [testSuiteV2PostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTestSuite(testSuiteV2PostModel?: TestSuiteV2PostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTestSuite(testSuiteV2PostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System deletes test suite  <br>System returns no content response
         * @summary Delete TestSuite
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTestSuite(testSuiteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTestSuite(testSuiteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configurations related to the test points  <br>System returns configurations array
         * @summary Get Configurations By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationsByTestSuiteId(testSuiteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurationsByTestSuiteId(testSuiteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System returns test points array
         * @summary Get TestPoints By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestPointsById(testSuiteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestPointByTestSuiteModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestPointsById(testSuiteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search test results related to the test points  <br>System returns test results array
         * @summary Get TestResults By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestResultsById(testSuiteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResultV2ShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestResultsById(testSuiteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System returns test suite
         * @summary Get TestSuite by Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestSuiteById(testSuiteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestSuiteById(testSuiteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>[Optional] User sets isDeleted property as true  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems related to the test points  <br>                      [Optional] User sets isDeleted property is set as true, System includes deleted workitems                      Otherwise, system applies filter which excludes deleted workitems from all found workitems                    <br>System returns workitems array
         * @summary Get WorkItems By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemsById(testSuiteId: string, isDeleted?: boolean, tagNames?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemsById(testSuiteId, isDeleted, tagNames, skip, take, orderBy, searchField, searchValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of configuration identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configuration  <br>System restores(if exist) or creates test points with listed configuration  <br>System returns no content response
         * @summary Set Configurations By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of configuration identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfigurationsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfigurationsByTestSuiteId(testSuiteId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of workitems identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems  <br>System restores(if exist) or creates test points with listed workitems  <br>System returns no content response
         * @summary Set WorkItems By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of workitem identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkItemsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemShortModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkItemsByTestSuiteId(testSuiteId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System updates test suite  <br>System returns test suite
         * @summary Update TestSuite
         * @param {TestSuiteV2PutModel} [testSuiteV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTestSuite(testSuiteV2PutModel?: TestSuiteV2PutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteV2GetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTestSuite(testSuiteV2PutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestSuitesApi - factory interface
 * @export
 */
export const TestSuitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestSuitesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add test-points to test suite
         * @param {string} testSuiteId Test suite internal identifier
         * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestPointsToTestSuite(testSuiteId: string, workItemSelectModel?: WorkItemSelectModel, options?: any): AxiosPromise<void> {
            return localVarFp.addTestPointsToTestSuite(testSuiteId, workItemSelectModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System creates test suite  <br>System returns test suite
         * @summary Create TestSuite
         * @param {TestSuiteV2PostModel} [testSuiteV2PostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestSuite(testSuiteV2PostModel?: TestSuiteV2PostModel, options?: any): AxiosPromise<TestSuiteV2GetModel> {
            return localVarFp.createTestSuite(testSuiteV2PostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System deletes test suite  <br>System returns no content response
         * @summary Delete TestSuite
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestSuite(testSuiteId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteTestSuite(testSuiteId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configurations related to the test points  <br>System returns configurations array
         * @summary Get Configurations By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationsByTestSuiteId(testSuiteId: string, options?: any): AxiosPromise<Array<ConfigurationModel>> {
            return localVarFp.getConfigurationsByTestSuiteId(testSuiteId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System returns test points array
         * @summary Get TestPoints By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestPointsById(testSuiteId: string, options?: any): AxiosPromise<Array<TestPointByTestSuiteModel>> {
            return localVarFp.getTestPointsById(testSuiteId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search test results related to the test points  <br>System returns test results array
         * @summary Get TestResults By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestResultsById(testSuiteId: string, options?: any): AxiosPromise<Array<TestResultV2ShortModel>> {
            return localVarFp.getTestResultsById(testSuiteId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System returns test suite
         * @summary Get TestSuite by Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestSuiteById(testSuiteId: string, options?: any): AxiosPromise<TestSuiteV2GetModel> {
            return localVarFp.getTestSuiteById(testSuiteId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>[Optional] User sets isDeleted property as true  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems related to the test points  <br>                      [Optional] User sets isDeleted property is set as true, System includes deleted workitems                      Otherwise, system applies filter which excludes deleted workitems from all found workitems                    <br>System returns workitems array
         * @summary Get WorkItems By Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
         * @param {Array<string>} [tagNames] Array of workitem tag names
         * @param {number} [skip] Amount of items to be skipped (offset)
         * @param {number} [take] Amount of items to be taken (limit)
         * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
         * @param {string} [searchField] Property name for searching
         * @param {string} [searchValue] Value for searching
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsById(testSuiteId: string, isDeleted?: boolean, tagNames?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: any): AxiosPromise<Array<WorkItemShortModel>> {
            return localVarFp.getWorkItemsById(testSuiteId, isDeleted, tagNames, skip, take, orderBy, searchField, searchValue, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of configuration identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configuration  <br>System restores(if exist) or creates test points with listed configuration  <br>System returns no content response
         * @summary Set Configurations By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of configuration identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigurationsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: any): AxiosPromise<Array<ConfigurationModel>> {
            return localVarFp.setConfigurationsByTestSuiteId(testSuiteId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of workitems identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems  <br>System restores(if exist) or creates test points with listed workitems  <br>System returns no content response
         * @summary Set WorkItems By TestSuite Id
         * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
         * @param {Set<string>} [requestBody] Collection of workitem identifiers\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkItemsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: any): AxiosPromise<Array<WorkItemShortModel>> {
            return localVarFp.setWorkItemsByTestSuiteId(testSuiteId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System updates test suite  <br>System returns test suite
         * @summary Update TestSuite
         * @param {TestSuiteV2PutModel} [testSuiteV2PutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestSuite(testSuiteV2PutModel?: TestSuiteV2PutModel, options?: any): AxiosPromise<TestSuiteV2GetModel> {
            return localVarFp.updateTestSuite(testSuiteV2PutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestSuitesApi - object-oriented interface
 * @export
 * @class TestSuitesApi
 * @extends {BaseAPI}
 */
export class TestSuitesApi extends BaseAPI {
    /**
     * 
     * @summary Add test-points to test suite
     * @param {string} testSuiteId Test suite internal identifier
     * @param {WorkItemSelectModel} [workItemSelectModel] Filter object to retrieve work items for test-suite\&#39;s project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public addTestPointsToTestSuite(testSuiteId: string, workItemSelectModel?: WorkItemSelectModel, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).addTestPointsToTestSuite(testSuiteId, workItemSelectModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System creates test suite  <br>System returns test suite
     * @summary Create TestSuite
     * @param {TestSuiteV2PostModel} [testSuiteV2PostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public createTestSuite(testSuiteV2PostModel?: TestSuiteV2PostModel, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).createTestSuite(testSuiteV2PostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System deletes test suite  <br>System returns no content response
     * @summary Delete TestSuite
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public deleteTestSuite(testSuiteId: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).deleteTestSuite(testSuiteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configurations related to the test points  <br>System returns configurations array
     * @summary Get Configurations By Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public getConfigurationsByTestSuiteId(testSuiteId: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).getConfigurationsByTestSuiteId(testSuiteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System returns test points array
     * @summary Get TestPoints By Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public getTestPointsById(testSuiteId: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).getTestPointsById(testSuiteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search test results related to the test points  <br>System returns test results array
     * @summary Get TestResults By Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public getTestResultsById(testSuiteId: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).getTestResultsById(testSuiteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User runs method execution  <br>System search test suite by identifier  <br>System returns test suite
     * @summary Get TestSuite by Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public getTestSuiteById(testSuiteId: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).getTestSuiteById(testSuiteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>[Optional] User sets isDeleted property as true  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems related to the test points  <br>                      [Optional] User sets isDeleted property is set as true, System includes deleted workitems                      Otherwise, system applies filter which excludes deleted workitems from all found workitems                    <br>System returns workitems array
     * @summary Get WorkItems By Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {boolean} [isDeleted] Flag that defines if deleted workitems must be include in the response
     * @param {Array<string>} [tagNames] Array of workitem tag names
     * @param {number} [skip] Amount of items to be skipped (offset)
     * @param {number} [take] Amount of items to be taken (limit)
     * @param {string} [orderBy] SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
     * @param {string} [searchField] Property name for searching
     * @param {string} [searchValue] Value for searching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public getWorkItemsById(testSuiteId: string, isDeleted?: boolean, tagNames?: Array<string>, skip?: number, take?: number, orderBy?: string, searchField?: string, searchValue?: string, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).getWorkItemsById(testSuiteId, isDeleted, tagNames, skip, take, orderBy, searchField, searchValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of configuration identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search configuration  <br>System restores(if exist) or creates test points with listed configuration  <br>System returns no content response
     * @summary Set Configurations By TestSuite Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {Set<string>} [requestBody] Collection of configuration identifiers\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public setConfigurationsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).setConfigurationsByTestSuiteId(testSuiteId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite identifier  <br>User sets collection of workitems identifiers  <br>User runs method execution  <br>System search test suite by identifier  <br>System search test points related to the test suite  <br>System search workitems  <br>System restores(if exist) or creates test points with listed workitems  <br>System returns no content response
     * @summary Set WorkItems By TestSuite Id
     * @param {string} testSuiteId Test suite internal (guid format) identifier\&quot;
     * @param {Set<string>} [requestBody] Collection of workitem identifiers\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public setWorkItemsByTestSuiteId(testSuiteId: string, requestBody?: Set<string>, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).setWorkItemsByTestSuiteId(testSuiteId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets test suite model (listed in request parameters)  <br>User runs method execution  <br>System updates test suite  <br>System returns test suite
     * @summary Update TestSuite
     * @param {TestSuiteV2PutModel} [testSuiteV2PutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuitesApi
     */
    public updateTestSuite(testSuiteV2PutModel?: TestSuiteV2PutModel, options?: AxiosRequestConfig) {
        return TestSuitesApiFp(this.configuration).updateTestSuite(testSuiteV2PutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System creates workitem by identifier  <br>System returns workitem model (listed in response parameters)
         * @summary Create Test Case, Checklist or Shared Step
         * @param {WorkItemPostModel} [workItemPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkItem: async (workItemPostModel?: WorkItemPostModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/workItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemPostModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search and delete all autotests, related to found workitem  <br>System returns no content response
         * @summary Delete all links AutoTests from WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkItemsFromAutoTest: async (workItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('deleteAllWorkItemsFromAutoTest', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}/autoTests`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System deletes workitem  <br>System returns no content response
         * @summary Delete Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkItem: async (workItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('deleteWorkItem', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search all autotests, related to found workitem  <br>System returns list of found autotests
         * @summary Get all AutoTests linked to WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestsForWorkItem: async (workItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('getAutoTestsForWorkItem', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}/autoTests`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get iterations by workitem Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIterations: async (workItemId: string, versionId?: string, versionNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('getIterations', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}/iterations`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }

            if (versionNumber !== undefined) {
                localVarQueryParameter['versionNumber'] = versionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>[Optional] User sets workitem version number  <br>User runs method execution  <br>System search workitem by identifier  <br>[Optional] if User sets workitem version identifier, system search workitem version by identifier.  <br>[Optional] if user sets workitem version number, system search workitem version by number  <br>Otherwise, system search last workitem version  <br>System returns workitem 
         * @summary Get Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier\&quot;
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemById: async (workItemId: string, versionId?: string, versionNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('getWorkItemById', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }

            if (versionNumber !== undefined) {
                localVarQueryParameter['versionNumber'] = versionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search test results of all autotests, related to found workitem  <br>System sort results by CompletedOn ascending, then by CreatedDate ascending  <br>System returns sorted collection of test results
         * @summary Get WorkItem chronology by Id or GlobalId
         * @param {string} workItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemChronology: async (workItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('getWorkItemChronology', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}/chronology`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>                      [Optional] If User set workitem version identifier, System search workitem version by version identifier                      Otherwise, system search all version of workitem                    <br>System returns array of workitem version models (listed in response example)
         * @summary Get WorkItem versions
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [workItemVersionId] WorkItem version (guid format)  identifier\&quot;
         * @param {number} [versionNumber] WorkItem version (integer format)  number\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemVersions: async (workItemId: string, workItemVersionId?: string, versionNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workItemId' is not null or undefined
            assertParamExists('getWorkItemVersions', 'workItemId', workItemId)
            const localVarPath = `/api/v2/workItems/{workItemId}/versions`
                .replace(`{${"workItemId"}}`, encodeURIComponent(String(workItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workItemVersionId !== undefined) {
                localVarQueryParameter['workItemVersionId'] = workItemVersionId;
            }

            if (versionNumber !== undefined) {
                localVarQueryParameter['versionNumber'] = versionNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System updates workitem by identifier  <br>System returns updated workitem model (listed in response parameters)
         * @summary Update Test Case, Checklist or Shared Step
         * @param {WorkItemPutModel} [workItemPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkItem: async (workItemPutModel?: WorkItemPutModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/workItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer or PrivateToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workItemPutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System creates workitem by identifier  <br>System returns workitem model (listed in response parameters)
         * @summary Create Test Case, Checklist or Shared Step
         * @param {WorkItemPostModel} [workItemPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkItem(workItemPostModel?: WorkItemPostModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkItem(workItemPostModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search and delete all autotests, related to found workitem  <br>System returns no content response
         * @summary Delete all links AutoTests from WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllWorkItemsFromAutoTest(workItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllWorkItemsFromAutoTest(workItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System deletes workitem  <br>System returns no content response
         * @summary Delete Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkItem(workItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkItem(workItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search all autotests, related to found workitem  <br>System returns list of found autotests
         * @summary Get all AutoTests linked to WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoTestsForWorkItem(workItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoTestModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoTestsForWorkItem(workItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get iterations by workitem Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIterations(workItemId: string, versionId?: string, versionNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IterationModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIterations(workItemId, versionId, versionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>[Optional] User sets workitem version number  <br>User runs method execution  <br>System search workitem by identifier  <br>[Optional] if User sets workitem version identifier, system search workitem version by identifier.  <br>[Optional] if user sets workitem version number, system search workitem version by number  <br>Otherwise, system search last workitem version  <br>System returns workitem 
         * @summary Get Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier\&quot;
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemById(workItemId: string, versionId?: string, versionNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemById(workItemId, versionId, versionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search test results of all autotests, related to found workitem  <br>System sort results by CompletedOn ascending, then by CreatedDate ascending  <br>System returns sorted collection of test results
         * @summary Get WorkItem chronology by Id or GlobalId
         * @param {string} workItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemChronology(workItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResultChronologyModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemChronology(workItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>                      [Optional] If User set workitem version identifier, System search workitem version by version identifier                      Otherwise, system search all version of workitem                    <br>System returns array of workitem version models (listed in response example)
         * @summary Get WorkItem versions
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [workItemVersionId] WorkItem version (guid format)  identifier\&quot;
         * @param {number} [versionNumber] WorkItem version (integer format)  number\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItemVersions(workItemId: string, workItemVersionId?: string, versionNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItemVersionModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItemVersions(workItemId, workItemVersionId, versionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System updates workitem by identifier  <br>System returns updated workitem model (listed in response parameters)
         * @summary Update Test Case, Checklist or Shared Step
         * @param {WorkItemPutModel} [workItemPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkItem(workItemPutModel?: WorkItemPutModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkItem(workItemPutModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System creates workitem by identifier  <br>System returns workitem model (listed in response parameters)
         * @summary Create Test Case, Checklist or Shared Step
         * @param {WorkItemPostModel} [workItemPostModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkItem(workItemPostModel?: WorkItemPostModel, options?: any): AxiosPromise<WorkItemModel> {
            return localVarFp.createWorkItem(workItemPostModel, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search and delete all autotests, related to found workitem  <br>System returns no content response
         * @summary Delete all links AutoTests from WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkItemsFromAutoTest(workItemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllWorkItemsFromAutoTest(workItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System deletes workitem  <br>System returns no content response
         * @summary Delete Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkItem(workItemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkItem(workItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search all autotests, related to found workitem  <br>System returns list of found autotests
         * @summary Get all AutoTests linked to WorkItem by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTestsForWorkItem(workItemId: string, options?: any): AxiosPromise<Array<AutoTestModel>> {
            return localVarFp.getAutoTestsForWorkItem(workItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get iterations by workitem Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIterations(workItemId: string, versionId?: string, versionNumber?: number, options?: any): AxiosPromise<Array<IterationModel>> {
            return localVarFp.getIterations(workItemId, versionId, versionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>[Optional] User sets workitem version number  <br>User runs method execution  <br>System search workitem by identifier  <br>[Optional] if User sets workitem version identifier, system search workitem version by identifier.  <br>[Optional] if user sets workitem version number, system search workitem version by number  <br>Otherwise, system search last workitem version  <br>System returns workitem 
         * @summary Get Test Case, Checklist or Shared Step by Id or GlobalId
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [versionId] WorkItem version (guid format) identifier\&quot;
         * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemById(workItemId: string, versionId?: string, versionNumber?: number, options?: any): AxiosPromise<WorkItemModel> {
            return localVarFp.getWorkItemById(workItemId, versionId, versionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search test results of all autotests, related to found workitem  <br>System sort results by CompletedOn ascending, then by CreatedDate ascending  <br>System returns sorted collection of test results
         * @summary Get WorkItem chronology by Id or GlobalId
         * @param {string} workItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemChronology(workItemId: string, options?: any): AxiosPromise<Array<TestResultChronologyModel>> {
            return localVarFp.getWorkItemChronology(workItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>                      [Optional] If User set workitem version identifier, System search workitem version by version identifier                      Otherwise, system search all version of workitem                    <br>System returns array of workitem version models (listed in response example)
         * @summary Get WorkItem versions
         * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
         * @param {string} [workItemVersionId] WorkItem version (guid format)  identifier\&quot;
         * @param {number} [versionNumber] WorkItem version (integer format)  number\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemVersions(workItemId: string, workItemVersionId?: string, versionNumber?: number, options?: any): AxiosPromise<Array<WorkItemVersionModel>> {
            return localVarFp.getWorkItemVersions(workItemId, workItemVersionId, versionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System updates workitem by identifier  <br>System returns updated workitem model (listed in response parameters)
         * @summary Update Test Case, Checklist or Shared Step
         * @param {WorkItemPutModel} [workItemPutModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkItem(workItemPutModel?: WorkItemPutModel, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkItem(workItemPutModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System creates workitem by identifier  <br>System returns workitem model (listed in response parameters)
     * @summary Create Test Case, Checklist or Shared Step
     * @param {WorkItemPostModel} [workItemPostModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public createWorkItem(workItemPostModel?: WorkItemPostModel, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).createWorkItem(workItemPostModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search and delete all autotests, related to found workitem  <br>System returns no content response
     * @summary Delete all links AutoTests from WorkItem by Id or GlobalId
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public deleteAllWorkItemsFromAutoTest(workItemId: string, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).deleteAllWorkItemsFromAutoTest(workItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System deletes workitem  <br>System returns no content response
     * @summary Delete Test Case, Checklist or Shared Step by Id or GlobalId
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public deleteWorkItem(workItemId: string, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).deleteWorkItem(workItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search all autotests, related to found workitem  <br>System returns list of found autotests
     * @summary Get all AutoTests linked to WorkItem by Id or GlobalId
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getAutoTestsForWorkItem(workItemId: string, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getAutoTestsForWorkItem(workItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get iterations by workitem Id or GlobalId
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {string} [versionId] WorkItem version (guid format) identifier
     * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getIterations(workItemId: string, versionId?: string, versionNumber?: number, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getIterations(workItemId, versionId, versionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>[Optional] User sets workitem version number  <br>User runs method execution  <br>System search workitem by identifier  <br>[Optional] if User sets workitem version identifier, system search workitem version by identifier.  <br>[Optional] if user sets workitem version number, system search workitem version by number  <br>Otherwise, system search last workitem version  <br>System returns workitem 
     * @summary Get Test Case, Checklist or Shared Step by Id or GlobalId
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {string} [versionId] WorkItem version (guid format) identifier\&quot;
     * @param {number} [versionNumber] WorkItem version number (0 is the last version)\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemById(workItemId: string, versionId?: string, versionNumber?: number, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemById(workItemId, versionId, versionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>System search test results of all autotests, related to found workitem  <br>System sort results by CompletedOn ascending, then by CreatedDate ascending  <br>System returns sorted collection of test results
     * @summary Get WorkItem chronology by Id or GlobalId
     * @param {string} workItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemChronology(workItemId: string, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemChronology(workItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem identifier  <br>[Optional] User sets workitem version identifier  <br>User runs method execution  <br>System search workitem by identifier  <br>                      [Optional] If User set workitem version identifier, System search workitem version by version identifier                      Otherwise, system search all version of workitem                    <br>System returns array of workitem version models (listed in response example)
     * @summary Get WorkItem versions
     * @param {string} workItemId WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param {string} [workItemVersionId] WorkItem version (guid format)  identifier\&quot;
     * @param {number} [versionNumber] WorkItem version (integer format)  number\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItemVersions(workItemId: string, workItemVersionId?: string, versionNumber?: number, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItemVersions(workItemId, workItemVersionId, versionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <br>Use case  <br>User sets workitem properties (listed in request parameters)  <br>User runs method execution  <br>System updates workitem by identifier  <br>System returns updated workitem model (listed in response parameters)
     * @summary Update Test Case, Checklist or Shared Step
     * @param {WorkItemPutModel} [workItemPutModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public updateWorkItem(workItemPutModel?: WorkItemPutModel, options?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).updateWorkItem(workItemPutModel, options).then((request) => request(this.axios, this.basePath));
    }
}


